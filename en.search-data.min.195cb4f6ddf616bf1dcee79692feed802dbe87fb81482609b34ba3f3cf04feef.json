[{"id":0,"href":"/posts/%E4%B8%AA%E4%BA%BA/","title":"个人","section":"  ","content":"写，就是为了记住。\n忘记过去就是背叛，不要忘记，不要悲伤\n明天是上帝给你的礼物，要好好珍惜。\n"},{"id":1,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/","title":"技术","section":"  ","content":"写，就是为了记住。\n忘记过去就是背叛，不要忘记，不要悲伤\n明天是上帝给你的礼物，要好好珍惜。\n"},{"id":2,"href":"/posts/%E6%AD%8C%E8%AF%8D/","title":"歌词","section":"  ","content":"写，就是为了记住。\n忘记过去就是背叛，不要忘记，不要悲伤\n明天是上帝给你的礼物，要好好珍惜。\n"},{"id":3,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/","title":"理论知识","section":"  ","content":"写，就是为了记住。\n忘记过去就是背叛，不要忘记，不要悲伤\n明天是上帝给你的礼物，要好好珍惜。\n"},{"id":4,"href":"/posts/%E6%9D%82%E6%80%9D/22%E5%B9%B4%E5%8E%BB%E6%B7%B1%E5%9C%B3%E8%AE%A1%E5%88%92/","title":"22年去深圳计划","section":"杂思","content":" 计划明细 # 项目项 具体值 出发时间 待定 出发工具 待定 目的地 固戌 要带的东西 见【物品清单】 要做的事情 见【事情清单】 物品清单 # 要带的东西 # 电脑 鼠标，键盘 手机 (mi9, iphone6坏掉的) 硬盘(一个256固态, 一个1T机械) 电水壶 背包 配件类，电脑充电器，手机充电器（typec，mirc) 几个n95口罩 两瓶水 毛巾、洗漱牙刷杯子牙膏 要买的东西 # 厨房用具：电饭煲， 锅 插板 显示器 洗澡: 拖鞋, 衣架 篮球鞋 事情清单 # 走之前要做的事 # 剪头发 收拾房间 到之后要做的事 # 打电话 相关信息 # 衡阳到深圳的交通费用\n火车，坐106，卧180，8小时\n顺风车，350，11个小时\n飞机，520，一天\n"},{"id":5,"href":"/posts/","title":"  ","section":"好记性不如烂笔头","content":"写，就是为了记住。\n忘记过去就是背叛，不要忘记，不要悲伤\n明天是上帝给你的礼物，要好好珍惜。\n"},{"id":6,"href":"/posts/%E6%9D%82%E6%80%9D/22%E5%B9%B4%E8%BF%87%E5%B9%B4%E8%BF%90%E5%8A%A8%E8%AE%B0%E8%B4%A6/","title":"22年过年运动记账","section":"杂思","content":" 1月4号 25\n1月5号 40\n1月6号 43 已结\n1月7号 40\n1月8号 35\n1月9号 60 已结\n1月10号 30\n1月11号 25\n1月13号 45 已结\n1月14号 40 （第十天）\n1月17号 30\n1月18号 2 已结\n1月19号 53\n1月20号 57\n1月21号 59 已结（剩下54元）\n1月25号 14\n1月26号 20\n1月27号 30 (已结)\n1月28号 73\n1月29号 34\n1月30号 37 已结\n320 = 140+65+53+57+5 已结清\n项目规则：\n跑步，一圈5元，每天最多跑4圈 深蹲，50个15元，每天最多做100个 羽毛球，20个4元，40个7元，60个10元，每天最多60个 "},{"id":7,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/git%E6%93%8D%E4%BD%9C/","title":"git操作","section":"技术","content":" Git 所有操作及命令 # Git 是一个分布式版本控制系统，常用于管理代码的版本和协作开发。以下是 Git 的一些常用操作和命令：\nusage: git [-v | --version] [-h | --help] [-C \u0026lt;path\u0026gt;] [-c \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;] [--exec-path[=\u0026lt;path\u0026gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare] [--git-dir=\u0026lt;path\u0026gt;] [--work-tree=\u0026lt;path\u0026gt;] [--namespace=\u0026lt;name\u0026gt;] [--config-env=\u0026lt;name\u0026gt;=\u0026lt;envvar\u0026gt;] \u0026lt;command\u0026gt; [\u0026lt;args\u0026gt;] These are common Git commands used in various situations: start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing one work on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink restore Restore working tree files rm Remove files from the working tree and from the index examine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug diff Show changes between commits, commit and working tree, etc grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree status grow, mark and tweak your common history branch List, create, or delete branches commit Record changes to the repository merge Join two or more development histories together rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state switch Switch branches tag Create, list, delete or verify a tag object signed with GPG collaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects Git diff # 在默认的 Git diff 输出中，您通常会看到以下内容：\n- 行：表示被删除的行。 + 行：表示被添加的行。 @@ -1,14 +1,22 @@：表示文件的上下文（context），以及行号的范围。 具体来说：\n@@ 标志表示一个差异块的开始。 -1,14 表示在原文件中，从第 1 行开始的 14 行代码。 +1,22 表示在修改后的文件中，从第 1 行开始的 22 行代码。 这个输出告诉您在两个版本之间的文件中，原始文件的第 1 行到第 14 行与修改后的文件的第 1 行到第 22 行之间有差异。\n通常，- 行下面的内容表示原文件的内容，+ 行下面的内容表示修改后的文件的内容。这使您可以轻松比较文件的变化。如果要了解更多关于 Git diff 的信息，您可以使用 git help diff 命令来查看 Git 的官方文档。\n"},{"id":8,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/hugo-%E6%96%B9%E6%B3%95%E5%8F%82%E8%80%83/","title":"Hugo 方法参考","section":"技术","content":" String:用于字符串处理 # trim ：从字符串中删除前导和尾随空格。 # {{ trim \u0026#34; 你好，世界！ \u0026#34; }} upper ：将字符串转换为小写或大写。 # {{ lower \u0026#34;你好\u0026#34; }} {{ upper \u0026#34;world\u0026#34; }} title ：将字符串中每个单词的首字母转换为大写。 # {{ title \u0026#34;hello world\u0026#34; }} replace ：用另一个子字符串替换子字符串的出现。 # {{ replace \u0026#34;你好，世界！\u0026#34; \u0026#34;你好\u0026#34; \u0026#34;嗨\u0026#34; }} substr ：返回给定字符串的子字符串，从指定位置开始，可选长度。 # {{ substr \u0026#34;你好，世界！\u0026#34; 7 5 }} len ：返回字符串的长度。 # {{ len \u0026#34;你好，世界！\u0026#34; }} printf ：使用fmt.Printf语法格式化字符串。 # {{ printf \u0026#34;你好，%s！\u0026#34; \u0026#34;世界\u0026#34; }} urlize ：将字符串转换为适合URL的格式。 # {{ urlize \u0026#34;这是一个示例字符串\u0026#34; }} humanize ：将字符串转换为人类可读的格式。 # {{ humanize \u0026#34;some_string\u0026#34; }} pluralize ：基于计数返回词的复数形式。 # {{ with index .Site.Data.translations (printf \u0026#34;%s.toml\u0026#34; .Site.Language.Lang) }} {{ .home | default \u0026#34;Home\u0026#34; | pluralize .Site.RegularPages | title }} {{ end }} Collections:用于集合处理 # 您好，这是Bing。我可以用md格式回答您的问题，给出一些常用的hugo函数的代码示例。请看以下内容：\nAfter(seq: Seq, item: Any) -\u0026gt; Seq: 返回一个序列，包含给定序列中指定元素之后的所有元素。如果给定序列中没有指定元素，返回空序列。例如： # {{ $seq := slice 1 2 3 4 5 }} {{ $item := 3 }} {{ $result := after $seq $item }} {{/* result = [4 5] */}} Append:(seq: Seq, item: Any) -\u0026gt; Seq: 返回一个新的序列，包含给定序列和指定元素的连接。例如： # {{ $seq := slice 1 2 3 }} {{ $item := 4 }} {{ $result := append $seq $item }} {{/* result = [1 2 3 4] */}} Apply:(seq: Seq, key: String, fn: Func) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中每个元素的key字段经过fn函数处理后的值。例如： # {{ $seq := slice (dict \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20) (dict \u0026#34;name\u0026#34; \u0026#34;Bob\u0026#34; \u0026#34;age\u0026#34; 25) }} {{ $key := \u0026#34;name\u0026#34; }} {{ $fn := upper }} {{ $result := apply $seq $key $fn }} {{/* result = [\u0026#34;ALICE\u0026#34; \u0026#34;BOB\u0026#34;] */}} Complement:(seq1: Seq, seq2: Seq) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中不在另一个序列中的元素。例如： # {{ $seq1 := slice 1 2 3 4 }} {{ $seq2 := slice 3 4 5 6 }} {{ $result := complement $seq1 $seq2 }} {{/* result = [1 2] */}} Delimit:(seq: Seq, delimiter: String) -\u0026gt; String: 返回一个字符串，包含给定序列中的元素用指定的分隔符连接起来。例如： # {{ $seq := slice \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; }} {{ $delimiter := \u0026#34;,\u0026#34; }} {{ $result := delimit $seq $delimiter }} {{/* result = \u0026#34;a,b,c\u0026#34; */}} Dictionary:(args: Any…) -\u0026gt; Map: 返回一个新的映射，包含给定的键值对。参数必须是偶数个，且奇数位的参数为键，偶数位的参数为值。例如： # {{ $result := dictionary \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20 }} {{/* result = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 20} */}} First:(limit: Int, seq: Seq) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的前limit个元素。如果limit大于给定序列的长度，返回整个序列。例如： # {{ $limit := 2 }} {{ $seq := slice 1 2 3 4 5 }} {{ $result := first $limit $seq }} {{/* result = [1 2] */}} Group:(seq: Seq, key: String) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的元素按照key字段的值分组后的结果。每个分组是一个映射，包含两个键：key和values。例如： # {{ $seq := slice (dict \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20) (dict \u0026#34;name\u0026#34; \u0026#34;Bob\u0026#34; \u0026#34;age\u0026#34; 25) (dict \u0026#34;name\u0026#34; \u0026#34;Charlie\u0026#34; \u0026#34;age\u0026#34; 20) }} {{ $key := \u0026#34;age\u0026#34; }} {{ $result := group $seq $key }} {{/* result = [{\u0026#34;age\u0026#34;: 20, \u0026#34;values\u0026#34;: [(dict \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20) (dict \u0026#34;name\u0026#34; \u0026#34;Charlie\u0026#34; \u0026#34;age\u0026#34; 20)]}, {\u0026#34;age\u0026#34;: 25, \u0026#34;values\u0026#34;: [(dict \u0026#34;name\u0026#34; \u0026#34;Bob\u0026#34; \u0026#34;age\u0026#34; 25)]}] */}} In:(seq: Seq, item: Any) -\u0026gt; Bool: 返回一个布尔值，表示给定的元素是否在给定的序列中。例如： # {{ $seq := slice 1 2 3 4 5 }} {{ $item := 3 }} {{ $result := in $seq $item }} {{/* result = true */}} Index:(seq: Seq, index: Int) -\u0026gt; Any: 返回给定序列中指定索引的元素。如果索引超出范围，返回nil。例如： # {{ $seq := slice 1 2 3 4 5 }} {{ $index := 2 }} {{ $result := index $seq $index }} {{/* result = 3 */}} Intersect:(seq1: Seq, seq2: Seq) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的公共元素。例如： # {{ $seq1 := slice 1 2 3 4 }} {{ $seq2 := slice 3 4 5 6 }} {{ $result := intersect $seq1 $seq2 }} {{/* result = [3 4] */}} IsSet:(seq: Seq, key: String) -\u0026gt; Bool: 返回一个布尔值，表示给定的序列是否包含指定的键。例如： # {{ $seq := dict \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20 }} {{ $key := \u0026#34;name\u0026#34; }} {{ $result := isset $seq $key }} {{/* result = true */}} KeyVals:(seq: Seq) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的键值对。每个键值对是一个包含两个元素的切片。例如： # {{ $seq := dict \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20 }} {{ $result := keyVals $seq }} {{/* result = [[\u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34;] [\u0026#34;age\u0026#34; 20]] */}} Last:(limit: Int, seq: Seq) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的后limit个元素。如果limit大于给定序列的长度，返回整个序列。例如： # {{ $limit := 2 }} {{ $seq := slice 1 2 3 4 5 }} {{ $result := last $limit $seq }} {{/* result = [4 5] */}} Merge:(seq1: Seq, seq2: Seq) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的元素合并后的结果。如果两个序列都是切片，返回一个新的切片。如果两个序列都是映射，返回一个新的映射，其中seq2中的键值对会覆盖seq1中的键值对。例如： # {{ $seq1 := slice 1 2 3 }} {{ $seq2 := slice 4 5 6 }} {{ $result := merge $seq1 $seq2 }} {{/* result = [1 2 3 4 5 6] */}} {{ $seq1 := dict \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20 }} {{ $seq2 := dict \u0026#34;age\u0026#34; 25 \u0026#34;gender\u0026#34; \u0026#34;female\u0026#34; }} {{ $result := merge $seq1 $seq2 }} {{/* result = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 25, \u0026#34;gender\u0026#34;: \u0026#34;female\u0026#34;} */}} NewScratch:() -\u0026gt; Scratch: 返回一个新的Scratch对象，用于在模板中存储临时数据。例如： # {{ $scratch := newScratch }} {{ $scratch.Set \u0026#34;foo\u0026#34; \u0026#34;bar\u0026#34; }} {{ $result := $scratch.Get \u0026#34;foo\u0026#34; }} {{/* result = \u0026#34;bar\u0026#34; */}} Querify:(args: Any…) -\u0026gt; String: 返回一个字符串，包含给定的键值对转换为URL查询参数的结果。参数必须是偶数个，且奇数位的参数为键，偶数位的参数为值。例如： # {{ $result := querify \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20 }} {{/* result = \u0026#34;name=Alice\u0026amp;age=20\u0026#34; */}} Reverse:(seq: Seq) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的元素反转后的结果。例如： # {{ $seq := slice 1 2 3 4 5 }} {{ $result := reverse $seq }} {{/* result = [5 4 3 2 1] */}} 好的，我继续回答您的问题，给出一些常用的hugo函数的代码示例。请看以下内容：\nSeq:(args: Any…) -\u0026gt; Seq: 返回一个新的序列，包含给定的参数。例如： # {{ $result := seq 1 2 3 4 5 }} {{/* result = [1 2 3 4 5] */}} Shuffle(seq: Seq) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的元素随机打乱后的结果。例如： # {{ $seq := slice 1 2 3 4 5 }} {{ $result := shuffle $seq }} {{/* result = [3 5 1 4 2] */}} Slice:(args: Any…) -\u0026gt; Slice: 返回一个新的切片，包含给定的参数。例如： # {{ $result := slice 1 2 3 4 5 }} {{/* result = [1 2 3 4 5] */}} Sort:(seq: Seq, key: String) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的元素按照key字段的值排序后的结果。如果key为空，按照元素本身的值排序。例如： # {{ $seq := slice 5 4 3 2 1 }} {{ $key := \u0026#34;\u0026#34; }} {{ $result := sort $seq $key }} {{/* result = [1 2 3 4 5] */}} {{ $seq := slice (dict \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20) (dict \u0026#34;name\u0026#34; \u0026#34;Bob\u0026#34; \u0026#34;age\u0026#34; 25) (dict \u0026#34;name\u0026#34; \u0026#34;Charlie\u0026#34; \u0026#34;age\u0026#34; 20) }} {{ $key := \u0026#34;name\u0026#34; }} {{ $result := sort $seq $key }} {{/* result = [(dict \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20) (dict \u0026#34;name\u0026#34; \u0026#34;Bob\u0026#34; \u0026#34;age\u0026#34; 25) (dict \u0026#34;name\u0026#34; \u0026#34;Charlie\u0026#34; \u0026#34;age\u0026#34; 20)] */}} SymDiff:(seq1: Seq, seq2: Seq) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的对称差集，即两个序列中不同时出现的元素。例如： # {{ $seq1 := slice 1 2 3 4 }} {{ $seq2 := slice 3 4 5 6 }} {{ $result := symDiff $seq1 $seq2 }} {{/* result = [1 2 5 6] */}} Union:(seq1: Seq, seq2: Seq) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的并集，即两个序列中的所有元素。例如： # {{ $seq1 := slice 1 2 3 4 }} {{ $seq2 := slice 3 4 5 6 }} {{ $result := union $seq1 $seq2 }} {{/* result = [1 2 3 4 5 6] */}} Uniq:(seq: Seq) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中的唯一元素，即去除重复的元素。例如： # {{ $seq := slice 1 2 3 3 4 4 5 }} {{ $result := uniq $seq }} {{/* result = [1 2 3 4 5] */}} Where:(seq: Seq, key: String, op: String, value: Any) -\u0026gt; Seq: 返回一个新的序列，包含给定序列中满足指定条件的元素。key是要比较的字段，op是要使用的比较运算符，value是要比较的值。op可以是以下之一：=，!=，\u0026lt;，\u0026lt;=，\u0026gt;，\u0026gt;=，in，not in。例如： # {{ $seq := slice (dict \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20) (dict \u0026#34;name\u0026#34; \u0026#34;Bob\u0026#34; \u0026#34;age\u0026#34; 25) (dict \u0026#34;name\u0026#34; \u0026#34;Charlie\u0026#34; \u0026#34;age\u0026#34; 20) }} {{ $key := \u0026#34;age\u0026#34; }} {{ $op := \u0026#34;=\u0026#34; }} {{ $value := 20 }} {{ $result := where $seq $key $op $value }} {{/* result = [(dict \u0026#34;name\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;age\u0026#34; 20) (dict \u0026#34;name\u0026#34; \u0026#34;Charlie\u0026#34; \u0026#34;age\u0026#34; 20)] */}} Compare: 两个或者多个值比较 # eq： 相等 # {{ if eq 2 2 }} \u0026lt;!-- 这个块将会执行，因为 2 等于 2 --\u0026gt; {{ else }} \u0026lt;!-- 这个块不会执行 --\u0026gt; {{ end }} ne： 不等 # {{ if ne 3 5 }} \u0026lt;!-- 这个块将会执行，因为 3 不等于 5 --\u0026gt; {{ else }} \u0026lt;!-- 这个块不会执行 --\u0026gt; {{ end }} gt： 大于 # {{ if gt 10 5 }} \u0026lt;!-- 这个块将会执行，因为 10 大于 5 --\u0026gt; {{ else }} \u0026lt;!-- 这个块不会执行 --\u0026gt; {{ end }} ge： 大于等于 # {{ if ge 7 7 }} \u0026lt;!-- 这个块将会执行，因为 7 大于等于 7 --\u0026gt; {{ else }} \u0026lt;!-- 这个块不会执行 --\u0026gt; {{ end }} lt： 小于 # {{ if lt 4 8 }} \u0026lt;!-- 这个块将会执行，因为 4 小于 8 --\u0026gt; {{ else }} \u0026lt;!-- 这个块不会执行 --\u0026gt; {{ end }} le： 小于等于 # {{ if le 6 6 }} \u0026lt;!-- 这个块将会执行，因为 6 小于等于 6 --\u0026gt; {{ else }} \u0026lt;!-- 这个块不会执行 --\u0026gt; {{ end }} and： 逻辑与 # {{ if and (eq 2 2) (gt 5 3) }} \u0026lt;!-- 这个块将会执行，因为两个条件都为真 --\u0026gt; {{ else }} \u0026lt;!-- 这个块不会执行 --\u0026gt; {{ end }} or： 逻辑或 # {{ if or (eq 2 3) (lt 5 3) }} \u0026lt;!-- 这个块将会执行，因为至少一个条件为真 --\u0026gt; {{ else }} \u0026lt;!-- 这个块不会执行 --\u0026gt; {{ end }} cond： 条件 # {{ cond (eq 2 2) \u0026#34;条件1为真\u0026#34; (ne 3 5) \u0026#34;条件2为真\u0026#34; (gt 10 5) \u0026#34;条件3为真\u0026#34; \u0026#34;默认条件\u0026#34; }} default： 默认 # {{ $value := default \u0026#34;default_value\u0026#34; .someVariable }} \u0026lt;!-- 如果 .someVariable 为空，则 $value 将设置为 \u0026#34;default_value\u0026#34; --\u0026gt; Data \u0026amp; Debug:数据和模板处理 # readFile： 读取本地文件 # {{ $localFileContent := readFile \u0026#34;path/to/local/file.txt\u0026#34; }} \u0026lt;!-- $localFileContent 将包含文件的内容 --\u0026gt; getJSON： 读取远程 JSON 文件 # {{ $remoteJsonData := getJSON \u0026#34;https://example.com/data.json\u0026#34; }} \u0026lt;!-- $remoteJsonData 将包含 JSON 文件的数据 --\u0026gt; getCSV： 读取远程 CSV 文件 # {{ $remoteCsvData := getCSV \u0026#34;https://example.com/data.csv\u0026#34; }} \u0026lt;!-- $remoteCsvData 将包含 CSV 文件的数据 --\u0026gt; dump： 打印变量详细信息 # {{ dump $remoteJsonData }} \u0026lt;!-- 使用 dump 打印 $remoteJsonData 变量的详细信息 --\u0026gt; timer： 计算模板执行时间 # {{ $timer := timer }} \u0026lt;!-- 执行一些模板操作 --\u0026gt; {{ $elapsedTime := $timer }} {{/* $elapsedTime 包含从 timer 开始到当前位置的时间间隔 */}} encoding 数据的编码和解码 # base64Encode 和 base64Decode： Base64 编码和解码 # {{ $originalData := \u0026#34;Hello, World!\u0026#34; }} {{ $encodedData := $originalData | base64Encode }} {{ $decodedData := $encodedData | base64Decode }} \u0026lt;!-- $encodedData 包含 \u0026#34;SGVsbG8sIFdvcmxkIQ==\u0026#34; --\u0026gt; \u0026lt;!-- $decodedData 包含 \u0026#34;Hello, World!\u0026#34; --\u0026gt; urlize 和 unurlize： URL 编码和解码 # {{ $originalData := \u0026#34;Hello, World!\u0026#34; }} {{ $urlEncodedData := $originalData | urlize }} {{ $urlDecodedData := $urlEncodedData | unurlize }} \u0026lt;!-- $urlEncodedData 包含 \u0026#34;Hello%2C%20World%21\u0026#34; --\u0026gt; \u0026lt;!-- $urlDecodedData 包含 \u0026#34;Hello, World!\u0026#34; --\u0026gt; jsonify： 将数据转换为 JSON 格式 # {{ $data := map \u0026#34;key\u0026#34; \u0026#34;value\u0026#34; }} {{ $jsonData := $data | jsonify }} \u0026lt;!-- $jsonData 包含 \u0026#39;{\u0026#34;key\u0026#34;:\u0026#34;value\u0026#34;}\u0026#39; --\u0026gt; Hugo 库 # hugo.BuildDate： 提供 Hugo 构建的日期和时间。 # hugo.CommitHash： 提供 Hugo 代码库的 Git 提交哈希。 # hugo.Deps： 提供 Hugo 使用的 Go 语言依赖项的信息。 # hugo.Environment： 提供 Hugo 当前运行的环境，例如 \u0026ldquo;production\u0026rdquo; 或 \u0026ldquo;development\u0026rdquo;。 # hugo.Generator： 提供 Hugo 站点生成器的信息。 # hugo.GoVersion： 提供 Hugo 使用的 Go 语言版本。 # hugo.IsDevelopment： 如果 Hugo 当前在开发环境中运行，则为 true。 # hugo.IsExtended： 如果 Hugo 当前是扩展版本，则为 true。 # hugo.IsProduction： 如果 Hugo 当前在生产环境中运行，则为 true。 # hugo.IsServer： 如果 Hugo 当前作为服务器运行，则为 true。 # hugo.Version： 提供 Hugo 的版本号。 # hugo.WorkingDir： 提供 Hugo 当前的工作目录。 # Image:图像处理库 # 以下是一些使用 images 包中的函数的代码示例：\nBrightness： 调整图像的亮度。 # {{ $brightImage := $image | images.Brightness 20 }} ColorBalance： 调整图像的色彩平衡。 # {{ $balancedImage := $image | images.ColorBalance 10 -5 15 }} Colorize： 对图像进行着色。 # {{ $colorizedImage := $image | images.Colorize \u0026#34;#FF0000\u0026#34; }} Config： 获取图像的配置信息。 # {{ $imageConfig := $image.Config }} Contrast： 调整图像的对比度。 # {{ $contrastedImage := $image | images.Contrast 10 }} Filter： 应用滤镜效果。 # {{ $filteredImage := $image | images.Filter \u0026#34;blur\u0026#34; }} Gamma： 调整图像的伽马值。 # {{ $gammaImage := $image | images.Gamma 1.5 }} GaussianBlur： 对图像应用高斯模糊。 # {{ $blurredImage := $image | images.GaussianBlur 5 }} Grayscale： 将图像转换为灰度。 # {{ $grayImage := $image | images.Grayscale }} Hue： 调整图像的色调。 # {{ $huedImage := $image | images.Hue 30 }} inflect:单词处理 # Humanize： 使单词更具人性化 # {{ $humanizedWord := i18n \u0026#34;word\u0026#34; 1 (slice \u0026#34;en\u0026#34; \u0026#34;humanize\u0026#34;) }} Pluralize： 将单词转为复数形式 # {{ $pluralWord := i18n \u0026#34;word\u0026#34; 2 (slice \u0026#34;en\u0026#34; \u0026#34;pluralize\u0026#34;) }} Singularize： 将单词转为单数形式 # {{ $singularWord := i18n \u0026#34;words\u0026#34; 1 (slice \u0026#34;en\u0026#34; \u0026#34;singularize\u0026#34;) }} Math:数字运算 # add： 加法 # {{ $sum := add 5 3 }} \u0026lt;!-- $sum 包含 8 --\u0026gt; sub： 减法 # {{ $difference := sub 10 3 }} \u0026lt;!-- $difference 包含 7 --\u0026gt; mul： 乘法 # {{ $product := mul 4 6 }} \u0026lt;!-- $product 包含 24 --\u0026gt; div： 除法 # {{ $quotient := div 12 4 }} \u0026lt;!-- $quotient 包含 3 --\u0026gt; mod： 取余 # {{ $remainder := mod 10 3 }} \u0026lt;!-- $remainder 包含 1 --\u0026gt; math.Abs： 绝对值 # {{ $absoluteValue := math.Abs -5 }} \u0026lt;!-- $absoluteValue 包含 5 --\u0026gt; math.Ceil 和 math.Floor： 向上取整和向下取整 # {{ $ceiledValue := math.Ceil 4.3 }} \u0026lt;!-- $ceiledValue 包含 5 --\u0026gt; {{ $flooredValue := math.Floor 4.8 }} \u0026lt;!-- $flooredValue 包含 4 --\u0026gt; math.Max 和 math.Min： 最大值和最小值 # {{ $maxValue := math.Max 10 7 }} \u0026lt;!-- $maxValue 包含 10 --\u0026gt; {{ $minValue := math.Min 5 3 }} \u0026lt;!-- $minValue 包含 3 --\u0026gt; math.Mod： 取余 # {{ $remainder := math.Mod 10 3 }} \u0026lt;!-- $remainder 包含 1 --\u0026gt; math.ModBool： 取余的布尔值 # {{ $isEven := math.ModBool 6 2 }} \u0026lt;!-- $isEven 包含 true --\u0026gt; math.Mul： 乘法 # {{ $product := math.Mul 4 6 }} \u0026lt;!-- $product 包含 24 --\u0026gt; math.Pow： 指数运算 # {{ $power := math.Pow 2 3 }} \u0026lt;!-- $power 包含 8 --\u0026gt; math.Product： 计算多个数字的乘积 # {{ $result := math.Product 2 3 4 }} \u0026lt;!-- $result 包含 24 --\u0026gt; math.Round： 四舍五入 # {{ $roundedValue := math.Round 4.5 }} \u0026lt;!-- $roundedValue 包含 5 --\u0026gt; math.Sqrt： 平方根 # {{ $squareRoot := math.Sqrt 16 }} \u0026lt;!-- $squareRoot 包含 4 --\u0026gt; math.Sub： 减法 # {{ $difference := math.Sub 10 3 }} \u0026lt;!-- $difference 包含 7 --\u0026gt; math.Sum： 计算多个数字的和 # {{ $total := math.Sum 2 3 4 }} \u0026lt;!-- $total 包含 9 --\u0026gt; OS:系统 # os.FileExists： 检查文件是否存在 # {{ $filePath := \u0026#34;path/to/file.txt\u0026#34; }} {{ with resources.Get $filePath }} {{ $fileExists := ne .MediaType.Type \u0026#34;unknown\u0026#34; }} {{ if $fileExists }} \u0026lt;!-- 文件存在的处理 --\u0026gt; {{ else }} \u0026lt;!-- 文件不存在的处理 --\u0026gt; {{ end }} {{ end }} os.Getenv： 获取环境变量 # 在 Hugo 模板中无法直接获取环境变量。建议在生成网站前使用其他工具或脚本设置环境变量。\nos.ReadDir： 读取目录内容 # {{ $dirPath := \u0026#34;path/to/directory\u0026#34; }} {{ $files := resources.Match $dirPath \u0026#34;**/*\u0026#34; }} {{ range $files }} {{ /* 处理每个文件 */ }} {{ end }} os.ReadFile： 读取文件内容 # {{ $filePath := \u0026#34;path/to/file.txt\u0026#34; }} {{ with resources.Get $filePath }} {{ $fileContent := .Content }} \u0026lt;!-- 使用 $fileContent 进行进一步处理 --\u0026gt; {{ end }} os.Stat： 获取文件状态 # {{ $filePath := \u0026#34;path/to/file.txt\u0026#34; }} {{ with resources.Get $filePath }} {{ $fileContent := .Content }} \u0026lt;!-- 使用 $fileContent 进行进一步处理 --\u0026gt; {{ end }} partial： 调用局部模板 # {{ partial \u0026#34;myPartial.html\u0026#34; . }} \u0026lt;!-- 调用名为 \u0026#34;myPartial.html\u0026#34; 的局部模板，并传递当前上下文数据（.） --\u0026gt; partialCached： 调用缓存的局部模板 # {{ partialCached \u0026#34;myCachedPartial.html\u0026#34; . \u0026#34;myCacheKey\u0026#34; }} \u0026lt;!-- 使用缓存键 \u0026#34;myCacheKey\u0026#34; 调用名为 \u0026#34;myCachedPartial.html\u0026#34; 的缓存局部模板，并传递当前上下文数据（.） --\u0026gt; 请注意，`partialCached` 函数允许您使用缓存键来缓存调用的结果，以提高性能。 Time:时间处理 # AsTime: 这个函数可以将一个字符串表示的日期/时间值转换为一个time.Time类型的值。您可以指定一个时区，如果不指定，就使用本地时区。例如： # {{ $input := \u0026#34;2023-11-27 16:06:22\u0026#34; }} {{ $timezone := \u0026#34;Asia/Singapore\u0026#34; }} {{ $result := time.AsTime $input $timezone }} {{/* result = 2023-11-27 16:06:22 +0800 +08 */}} Duration: 这个函数可以根据给定的时间单位和数字，返回一个time.Duration类型的值。时间单位可以是以下之一：ns，us，ms，s，m，h。例如： # {{ $time_unit := \u0026#34;s\u0026#34; }} {{ $number := 60 }} {{ $result := time.Duration $time_unit $number }} {{/* result = 1m0s */}} Format: 这个函数可以将一个日期/时间值格式化为一个字符串，您可以指定一个布局来控制输出的格式。您也可以使用一些预定义的布局，如ANSIC，UnixDate，RFC3339等。例如： # {{ $layout := \u0026#34;2006-01-02 15:04:05\u0026#34; }} {{ $input := time.Now }} {{ $result := time.Format $layout $input }} {{/* result = \u0026#34;2023-11-27 16:06:22\u0026#34; */}} Now: 这个函数可以返回当前的本地时间，是一个time.Time类型的值。例如： # {{ $result := time.Now }} {{/* result = 2023-11-27 16:06:22 +0800 +08 */}} ParseDuration: 这个函数可以将一个字符串表示的持续时间值转换为一个time.Duration类型的值。字符串必须符合以下格式：[number][unit]，其中number是一个十进制数，unit是一个时间单位，可以是以下之一：ns，us，ms，s，m，h。例如： # {{ $duration := \u0026#34;1h30m\u0026#34; }} {{ $result := time.ParseDuration $duration }} {{/* result = 1h30m0s */}} Layout string:格式化字符参照 # 时间 内容 年 \u0026ldquo;2006\u0026rdquo; \u0026ldquo;06\u0026rdquo; 月 \u0026ldquo;Jan\u0026rdquo; \u0026ldquo;January\u0026rdquo; \u0026ldquo;01\u0026rdquo; \u0026ldquo;1\u0026rdquo; 星期几 \u0026ldquo;Mon\u0026rdquo; \u0026ldquo;Monday\u0026rdquo; 月的第几天 \u0026ldquo;2\u0026rdquo; \u0026ldquo;_2\u0026rdquo; \u0026ldquo;02\u0026rdquo; 年的第几天 \u0026ldquo;__2\u0026rdquo; \u0026ldquo;002\u0026rdquo; 几点 \u0026ldquo;15\u0026rdquo; \u0026ldquo;3\u0026rdquo; \u0026ldquo;03\u0026rdquo; 几分 \u0026ldquo;4\u0026rdquo; \u0026ldquo;04\u0026rdquo; 几秒 \u0026ldquo;5\u0026rdquo; \u0026ldquo;05\u0026rdquo; 上午还是下午 \u0026ldquo;PM\u0026rdquo; 时区 \u0026ldquo;-0700\u0026rdquo; \u0026ldquo;-07:00\u0026rdquo; \u0026ldquo;-07\u0026rdquo; \u0026ldquo;-070000\u0026rdquo; \u0026ldquo;-07:00:00\u0026rdquo; "},{"id":9,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/markdown-%E8%AF%AD%E6%B3%95/","title":"markDown 语法","section":"技术","content":" 标题：使用\u0026quot;#\u0026ldquo;字符表示标题，数量代表标题级别，最多支持6级标题。例如：\n# 一级标题 ## 二级标题 ### 三级标题 ... ###### 六级标题 段落：段落之间以空行分隔。\n强调：使用\u0026rdquo;*\u0026ldquo;或\u0026rdquo;_\u0026ldquo;将需要强调的文本包围起来。例如：\n*斜体* _斜体_ **粗体** __粗体__ ***粗斜体*** ___粗斜体___ 列表：有序列表以数字和句点开始，无序列表以\u0026rdquo;*\u0026quot;、\u0026quot;+\u0026ldquo;或\u0026rdquo;-\u0026ldquo;开始。例如：\n1. 第一项 2. 第二项 3. 第三项 - 无序列表项1 - 无序列表项2 - 嵌套的无序列表项 - 更深层次的无序列表项 * 无序列表项A * 无序列表项B * 嵌套的无序列表项 * 更深层次的无序列表项 + 无序列表项X + 无序列表项Y + 嵌套的无序列表项 + 更深层次的无序列表项 链接：使用\u0026rdquo; 链接文本\u0026ldquo;的格式添加链接。例如：\n[Google](https://www.google.com) 图片：使用\u0026rdquo; \u0026ldquo;的格式插入图片。例如：\n![示例图片](https://example.com/image.jpg) 引用：使用\u0026rdquo;\u0026gt;\u0026ldquo;字符表示引用。例如：\n\u0026gt; 这是一段引用的文本。 代码块：使用三个反引号(`)包围代码块，并在开始位置指定代码语言（可选）。例如：\ndef hello_world(): print(\u0026#34;Hello, world!\u0026#34;) 表格：使用\u0026rdquo;|\u0026ldquo;和\u0026rdquo;-\u0026ldquo;分隔表头和表格内容，并使用\u0026rdquo;:\u0026ldquo;来对齐表格内容。例如：\n| 列1标题 | 列2标题 | |---------|---------| | 内容1 | 内容2 | | 内容3 | 内容4 | 左对齐列1标题 | 右对齐列2标题 :------------|-------------: 左对齐内容1 | 右对齐内容2 左对齐内容3 | 右对齐内容4 水平线：使用三个或更多连续的\u0026rdquo;*\u0026quot;、\u0026quot;-\u0026ldquo;或\u0026rdquo;_\u0026ldquo;表示水平线。例如：\n*** --- ___ "},{"id":10,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/python-%E6%96%B9%E6%B3%95%E5%8F%82%E8%80%83/","title":"python 方法参考","section":"技术","content":" Number(数字) # ceil(x)： 返回不小于 x 的最小整数 # import math result = math.ceil(4.2) # 返回 5 floor(x)： 返回不大于 x 的最大整数 # import math result = math.floor(4.8) # 返回 4 sqrt(x)： 返回 x 的平方根 # import math result = math.sqrt(25) # 返回 5.0 pow(x, y)： 返回 x 的 y 次方 # import math result = math.pow(2, 3) # 返回 8.0 exp(x)： 返回 e 的 x 次方 # import math result = math.exp(2) # 返回 7.389... log(x)： 返回 x 的自然对数 # import math result = math.log(10) # 返回 2.302... log10(x)： 返回 x 的以 10 为底的对数 # import math result = math.log10(100) # 返回 2.0 sin(x)： 返回 x 弧度的正弦值 # import math result = math.sin(math.pi/2) # 返回 1.0 cos(x)： 返回 x 弧度的余弦值 # import math result = math.cos(0) # 返回 1.0 tan(x)： 返回 x 弧度的正切值 # import math result = math.tan(math.pi/4) # 返回 1.0 random.random()： 返回 [0.0, 1.0) 范围内的随机浮点数 # import random result = random.random() # 返回 0.523... random.randint(a, b)： 返回 [a, b] 范围内的随机整数 # import random result = random.randint(1, 10) # 返回 5 random.choice(seq)： 从序列中随机选择一个元素 # import random result = random.choice([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;]) # 返回 \u0026#39;banana\u0026#39; random.shuffle(seq)： 随机打乱序列中的元素 # import random mylist = [1, 2, 3, 4, 5] random.shuffle(mylist) # mylist 现在被随机打乱 random.sample(population, k)： 从总体中选择 k 个不重复的元素 # import random result = random.sample([1, 2, 3, 4, 5], 3) # 返回 [2, 5, 1] sin(x)： 返回 x 弧度的正弦值 # import math result = math.sin(math.pi/2) # 返回 1.0 cos(x)： 返回 x 弧度的余弦值 # import math result = math.cos(0) # 返回 1.0 tan(x)： 返回 x 弧度的正切值 # import math result = math.tan(math.pi/4) # 返回 1.0 asin(x)： 返回 x 的反正弦值 # import math result = math.asin(1) # 返回 pi/2 acos(x)： 返回 x 的反余弦值 # import math result = math.acos(0) # 返回 pi/2 atan(x)： 返回 x 的反正切值 # import math result = math.atan(1) # 返回 pi/4 pi： 圆周率 # import math result = math.pi # 返回 3.141592653589793 e： 自然对数的底 # import math result = math.e # 返回 2.718281828459045 # String(字符串) #### **capitalize()：** 将字符串的第一个字符大写 ```python result = \u0026#39;hello world\u0026#39;.capitalize() # 返回 \u0026#39;Hello world\u0026#39; casefold()： 将字符串中所有字符转换为小写，并处理特殊字符 # result = \u0026#39;Hello World\u0026#39;.casefold() # 返回 \u0026#39;hello world\u0026#39; center(width[, fillchar])： 返回一个指定宽度的居中字符串，可指定填充字符 # result = \u0026#39;hello\u0026#39;.center(10) # 返回 \u0026#39; hello \u0026#39; count(sub[, start[, end]])： 返回字符串中子字符串出现的次数 # result = \u0026#39;hello hello\u0026#39;.count(\u0026#39;hello\u0026#39;) # 返回 2 encode([encoding[, errors]])： 返回字符串的编码版本 # result = \u0026#39;hello\u0026#39;.encode(\u0026#39;utf-8\u0026#39;) # 返回 b\u0026#39;hello\u0026#39; endswith(suffix[, start[, end]])： 检查字符串是否以指定后缀结束 # result = \u0026#39;hello world\u0026#39;.endswith(\u0026#39;world\u0026#39;) # 返回 True expandtabs([tabsize])： 将字符串中的制表符扩展为空格 # result = \u0026#39;hello\\tworld\u0026#39;.expandtabs(4) # 返回 \u0026#39;hello world\u0026#39; find(sub[, start[, end]])： 查找子字符串第一次出现的位置，未找到返回 -1 # result = \u0026#39;hello world\u0026#39;.find(\u0026#39;world\u0026#39;) # 返回 6 **format(*args, kwargs)： 格式化字符串 # result = \u0026#39;My name is {} and I\\\u0026#39;m {} years old\u0026#39;.format(\u0026#39;Alice\u0026#39;, 30) # 返回 \u0026#39;My name is Alice and I\u0026#39;m 30 years old\u0026#39; format_map(mapping)： 使用字典或其他映射来格式化字符串 # result = \u0026#39;My name is {name} and I\\\u0026#39;m {age} years old\u0026#39;.format_map({\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30}) # 返回 \u0026#39;My name is Alice and I\u0026#39;m 30 years old\u0026#39; index(sub[, start[, end]])： 查找子字符串第一次出现的位置，未找到引发 ValueError # result = \u0026#39;hello world\u0026#39;.index(\u0026#39;world\u0026#39;) # 返回 6 isalnum()： 检查字符串是否由字母和数字组成 # result = \u0026#39;hello123\u0026#39;.isalnum() # 返回 True isalpha()： 检查字符串是否由字母组成 # result = \u0026#39;hello\u0026#39;.isalpha() # 返回 True isascii()： 检查字符串是否仅包含 ASCII 字符 # result = \u0026#39;hello\u0026#39;.isascii() # 返回 True isdecimal()： 检查字符串是否只包含十进制字符 # result = \u0026#39;12345\u0026#39;.isdecimal() # 返回 True isdigit()： 检查字符串是否只包含数字 # result = \u0026#39;12345\u0026#39;.isdigit() # 返回 True isidentifier()： 检查字符串是否是有效的标识符 # result = \u0026#39;hello123\u0026#39;.isidentifier() # 返回 False islower()： 检查字符串是否都是小写字母 # result = \u0026#39;hello\u0026#39;.islower() # 返回 True isnumeric()： 检查字符串是否只包含数字字符 # result = \u0026#39;12345\u0026#39;.isnumeric() # 返回 True isprintable()： 检查字符串是否是可打印的 # result = \u0026#39;hello\\nworld\u0026#39;.isprintable() # 返回 False isspace()： 检查字符串是否只包含空格字符 # result = \u0026#39; \u0026#39;.isspace() # 返回 True istitle()： 检查字符串是否是标题化的（每个单词的首字母大写） # result = \u0026#39;Hello World\u0026#39;.istitle() # 返回 True isupper()： 检查字符串是否都是大写字母 # result = \u0026#39;HELLO\u0026#39;.isupper() # 返回 True join(iterable)： 将可迭代对象的元素连接成字符串 # result = \u0026#39;,\u0026#39;.join([\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;]) # 返回 \u0026#39;apple,banana,orange\u0026#39; ljust(width[, fillchar])： 返回一个指定宽度的左对齐字符串，可指定填充字符 # result = \u0026#39;hello\u0026#39;.ljust(10) # 返回 \u0026#39;hello \u0026#39; lower()： 将字符串转换为小写 # result = \u0026#39;Hello World\u0026#39;.lower() # 返回 \u0026#39;hello world\u0026#39; lstrip([chars])： 去除字符串左边的指定字符，默认为空格 # result = \u0026#39; hello\u0026#39;.lstrip() # 返回 \u0026#39;hello\u0026#39; maketrans(x[, y[, z]])： 创建字符映射转换表 # trans = str.maketrans(\u0026#39;aeiou\u0026#39;, \u0026#39;12345\u0026#39;) partition(sep)： 根据第一次出现的分隔符将字符串分成三部分 # result = \u0026#39;hello world\u0026#39;.partition(\u0026#39;o\u0026#39;) # 返回 (\u0026#39;hell\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39; world\u0026#39;) replace(old, new[, count])： 将字符串中的指定子字符串替换为新字符串 # result = \u0026#39;hello world\u0026#39;.replace(\u0026#39;world\u0026#39;, \u0026#39;universe\u0026#39;) # 返回 \u0026#39;hello universe\u0026#39; rfind(sub[, start[, end]])： 查找子字符串最后一次出现的位置，未找到返回 -1 # result = \u0026#39;hello world\u0026#39;.rfind(\u0026#39;o\u0026#39;) # 返回 7 rindex(sub[, start[, end]])： 查找子字符串最后一次出现的位置，未找到引发 ValueError # result = \u0026#39;hello world\u0026#39;.rindex(\u0026#39;o\u0026#39;) # 返回 7 rjust(width[, fillchar])： 返回一个指定宽度的右对齐字符串，可指定填充字符 # result = \u0026#39;hello\u0026#39;.rjust(10) # 返回 \u0026#39; hello\u0026#39; rpartition(sep)： 根据最后一次出现的分隔符将字符串分成三部分 # result = \u0026#39;hello world\u0026#39;.rpartition(\u0026#39;o\u0026#39;) # 返回 (\u0026#39;hello w\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;rld\u0026#39;) rsplit([sep[, maxsplit]])： 从右边开始拆分字符串 # result = \u0026#39;hello world\u0026#39;.rsplit(\u0026#39; \u0026#39;) # 返回 [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;] rstrip([chars])： 去除字符串右边的指定字符，默认为空格 # result = \u0026#39;hello \u0026#39;.rstrip() # 返回 \u0026#39;hello\u0026#39; split([sep[, maxsplit]])： 拆分字符串 # result = \u0026#39;hello world\u0026#39;.split(\u0026#39; \u0026#39;) # 返回 [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;] splitlines([keepends])： 按行拆分字符串 # result = \u0026#39;hello\\nworld\u0026#39;.splitlines() # 返回 [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;] startswith(prefix[, start[, end]])： 检查字符串是否以指定前缀开头 # result = \u0026#39;hello world\u0026#39;.startswith(\u0026#39;hello\u0026#39;) # 返回 True strip([chars])： 去除字符串两边的指定字符，默认为空格 # result = \u0026#39; hello \u0026#39;.strip() # 返回 \u0026#39;hello\u0026#39; swapcase()： 将字符串中的大小写翻转 # result = \u0026#39;Hello World\u0026#39;.swapcase() # 返回 \u0026#39;hELLO wORLD\u0026#39; title()： 将字符串转换为标题化的形式 # result = \u0026#39;hello world\u0026#39;.title() # 返回 \u0026#39;Hello World\u0026#39; upper()： 将字符串转换为大写 # result = \u0026#39;hello world\u0026#39;.upper() # 返回 \u0026#39;HELLO WORLD\u0026#39; zfill(width)： 返回一个指定宽度的右对齐字符串，前面填充0 # result = \u0026#39;42\u0026#39;.zfill(5) # 返回 \u0026#39;00042\u0026#39; List(列表) # len(list)： 返回列表元素的个数 # result = len([1, 2, 3]) # 返回 3 *max(iterable, [, key, default])： 返回可迭代对象中最大的元素 # result = max([1, 3, 2]) # 返回 3 *min(iterable, [, key, default])： 返回可迭代对象中最小的元素 # result = min([1, 3, 2]) # 返回 1 sum(iterable, /, start=0)： 返回可迭代对象中所有元素的和 # result = sum([1, 2, 3]) # 返回 6 *sorted(iterable, [, key, reverse])： 返回一个排序后的列表 # result = sorted([3, 1, 2]) # 返回 [1, 2, 3] list(iterable)： 将可迭代对象转换为列表 # result = list((1, 2, 3)) # 返回 [1, 2, 3] any(iterable)： 如果可迭代对象中至少有一个元素为 True，则返回 True # result = any([False, True, False]) # 返回 True all(iterable)： 如果可迭代对象中所有元素都为 True，则返回 True # result = all([True, True, True]) # 返回 True enumerate(iterable, start=0)： 返回可迭代对象中元素的索引和值 # result = list(enumerate([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;])) # 返回 [(0, \u0026#39;a\u0026#39;), (1, \u0026#39;b\u0026#39;), (2, \u0026#39;c\u0026#39;)] filter(function, iterable)： 使用函数过滤可迭代对象中的元素 # result = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4])) # 返回 [2, 4] map(function, iterable, \u0026hellip;)： 将函数应用于可迭代对象中的每个元素 # result = list(map(lambda x: x * 2, [1, 2, 3])) # 返回 [2, 4, 6] reversed(seq)： 返回反转的可迭代对象 # result = list(reversed([1, 2, 3])) # 返回 [3, 2, 1] zip(iter1, iter2, \u0026hellip;)： 返回元组的迭代器，其中的元素来自各个可迭代对象 # result = list(zip([1, 2, 3], [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;])) # 返回 [(1, \u0026#39;a\u0026#39;), (2, \u0026#39;b\u0026#39;), (3, \u0026#39;c\u0026#39;)] append(x)： 在列表末尾添加元素 # mylist = [1, 2, 3] mylist.append(4) extend(iterable)： 将可迭代对象的元素追加到列表末尾 # mylist = [1, 2, 3] mylist.extend([4, 5]) insert(i, x)： 在指定位置插入元素 # mylist = [1, 2, 3] mylist.insert(1, 4) remove(x)： 移除列表中第一个值为 x 的元素 # mylist = [1, 2, 3] mylist.remove(2) pop([i])： 移除并返回指定位置的元素，默认移除最后一个元素 # mylist = [1, 2, 3] element = mylist.pop(1) clear()： 移除列表中的所有元素 # mylist = [1, 2, 3] mylist.clear() index(x[, start[, end]])： 返回第一个值为 x 的元素的索引 # mylist = [1, 2, 3] index = mylist.index(2) count(x)： 返回值为 x 的元素在列表中出现的次数 # mylist = [1, 2, 2, 3] count = mylist.count(2) sort(*[, key, reverse])： 对列表进行排序 # mylist = [3, 1, 2] mylist.sort() reverse()： 反转列表中的元素 # mylist = [1, 2, 3] mylist.reverse() copy()： 返回列表的浅复制 # mylist = [1, 2, 3] newlist = mylist.copy() Dict(字典) # clear： 移除字典中的所有元素 # mydict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} mydict.clear() copy： 返回字典的浅复制 # mydict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} newdict = mydict.copy() fromkeys(seq[, value])： 创建一个新字典，以序列中的元素作为键，值为 value（默认为 None） # result = dict.fromkeys([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;], 0) # 返回 {\u0026#39;a\u0026#39;: 0, \u0026#39;b\u0026#39;: 0} get(key[, default])： 返回指定键的值，如果键不存在则返回默认值 # mydict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} result = mydict.get(\u0026#39;a\u0026#39;, 0) # 返回 1 items： 返回字典中包含的所有键值对的视图 # mydict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} result = mydict.items() # 返回 dict_items([(\u0026#39;a\u0026#39;, 1), (\u0026#39;b\u0026#39;, 2)]) keys： 返回字典中所有键的视图 # mydict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} result = mydict.keys() # 返回 dict_keys([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]) values： 返回字典中所有值的视图 # mydict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} result = mydict.values() # 返回 dict_values([1, 2]) pop(key[, default])： 移除并返回指定键的值，如果键不存在则返回默认值 # mydict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} result = mydict.pop(\u0026#39;a\u0026#39;) # 返回 1 popitem： 随机移除并返回字典中的一对键值对 # mydict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} result = mydict.popitem() # 返回 (\u0026#39;a\u0026#39;, 1) setdefault(key[, default])： 返回指定键的值，如果键不存在则设置默认值 # mydict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} result = mydict.setdefault(\u0026#39;c\u0026#39;, 0) # 返回 0 update([other])： 更新字典，将其他字典或键值对添加到该字典 # mydict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} mydict.update({\u0026#39;c\u0026#39;: 3}) Set(集合) # add： 向集合添加元素 # myset = {1, 2, 3} myset.add(4) clear： 移除集合中的所有元素 # myset = {1, 2, 3} myset.clear() copy： 返回集合的浅复制 # myset = {1, 2, 3} newset = myset.copy() difference： 返回与其他集合的差集 # myset = {1, 2, 3} other_set = {2, 3, 4} result = myset.difference(other_set) difference_update： 移除与其他集合的相同元素 # myset = {1, 2, 3} other_set = {2, 3, 4} myset.difference_update(other_set) discard： 移除集合中的指定元素，如果不存在则不报错 # myset = {1, 2, 3} myset.discard(2) intersection： 返回与其他集合的交集 # myset = {1, 2, 3} other_set = {2, 3, 4} result = myset.intersection(other_set) intersection_update： 保留与其他集合的交集，移除其他元素 # myset = {1, 2, 3} other_set = {2, 3, 4} myset.intersection_update(other_set) isdisjoint： 如果两个集合没有相同的元素，返回 True # myset = {1, 2, 3} other_set = {4, 5, 6} result = myset.isdisjoint(other_set) issubset： 如果集合是其他集合的子集，返回 True # myset = {1, 2} other_set = {1, 2, 3} result = myset.issubset(other_set) issuperset： 如果集合是其他集合的超集，返回 True # myset = {1, 2, 3} other_set = {1, 2} result = myset.issuperset(other_set) pop： 移除并返回集合中的一个任意元素，如果集合为空则报错 # myset = {1, 2, 3} element = myset.pop() remove： 移除集合中的指定元素，如果不存在则报错 # myset = {1, 2, 3} myset.remove(2) symmetric_difference： 返回与其他集合的对称差集 # myset = {1, 2, 3} other_set = {2, 3, 4} result = myset.symmetric_difference(other_set) symmetric_difference_update： 更新集合为与其他集合的对称差集 # myset = {1, 2, 3} other_set = {2, 3, 4} myset.symmetric_difference_update(other_set) union： 返回与其他集合的并集 # myset = {1, 2, 3} other_set = {3, 4, 5} result = myset.union(other_set) update： 更新集合为与其他集合的并集 # myset = {1, 2, 3} other_set = {3, 4, 5} myset.update(other_set) File(文件) # 以下是 Python 中与文件 (File) 相关的方法：\nopen(file, mode=\u0026lsquo;r\u0026rsquo;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)： 打开文件并返回文件对象 # file = open(\u0026#39;example.txt\u0026#39;, \u0026#39;r\u0026#39;) # 打开名为 \u0026#39;example.txt\u0026#39; 的文件以供读取 file.read(size=-1)： 读取文件中的指定字节数或全部内容 # content = file.read() # 读取整个文件内容 file.readline(size=-1)： 读取文件中的一行内容 # line = file.readline() # 读取文件的一行 file.readlines(hint=-1)： 读取文件中的所有行并返回列表 # lines = file.readlines() # 读取文件的所有行并返回列表 file.write(string)： 将字符串写入文件 # file.write(\u0026#39;Hello, World!\u0026#39;) # 将字符串写入文件 file.writelines(lines)： 将字符串列表写入文件 # lines = [\u0026#39;Line 1\\n\u0026#39;, \u0026#39;Line 2\\n\u0026#39;, \u0026#39;Line 3\\n\u0026#39;] file.writelines(lines) # 将字符串列表写入文件 file.flush()： 刷新文件缓冲区 # file.flush() # 刷新文件缓冲区 file.close()： 关闭文件 # file.close() # 关闭文件 file.seek(offset, whence=0)： 移动文件指针到指定位置 # file.seek(0) # 移动文件指针到文件开头 file.tell()： 返回文件指针当前位置 # position = file.tell() # 返回文件指针当前位置 file.truncate(size=None)： 截断文件到指定大小 # file.truncate(10) # 将文件截断到 10 个字节 os.path.exists(path)： 检查文件或目录是否存在 # import os exists = os.path.exists(\u0026#39;example.txt\u0026#39;) # 检查文件是否存在 os.path.isfile(path)： 检查路径是否为文件 # import os is_file = os.path.isfile(\u0026#39;example.txt\u0026#39;) # 检查路径是否为文件 os.path.isdir(path)： 检查路径是否为目录 # import os is_directory = os.path.isdir(\u0026#39;my_folder\u0026#39;) # 检查路径是否为目录 os.path.getsize(path)： 获取文件大小 # import os size = os.path.getsize(\u0026#39;example.txt\u0026#39;) # 获取文件大小 这些方法用于处理文件的打开、读取、写入、关闭等操作，同时也包括了一些通过 os 模块检查文件状态的方法。\nOS(系统) # 以下是 Python 3 中与文件和目录操作相关的一些常用的 os 模块方法：\nos.getcwd()： 获取当前工作目录 # import os current_directory = os.getcwd() # 获取当前工作目录 os.chdir(path)： 修改当前工作目录 # import os os.chdir(\u0026#39;/path/to/directory\u0026#39;) # 将当前工作目录切换到指定路径 os.listdir(path=\u0026rsquo;.\u0026rsquo;)： 返回指定目录下的所有文件和目录列表 # import os contents = os.listdir(\u0026#39;/path/to/directory\u0026#39;) # 获取指定目录下的所有文件和目录列表 *os.mkdir(path, mode=0o777, , dir_fd=None)： 创建新目录 # import os os.mkdir(\u0026#39;/path/to/new_directory\u0026#39;) # 在指定路径下创建新目录 os.makedirs(name, mode=0o777, exist_ok=False)： 递归地创建新目录 # import os os.makedirs(\u0026#39;/path/to/new/directory\u0026#39;, exist_ok=True) # 递归地在指定路径下创建新目录，如果目录已存在且 exist_ok 为 True，则不会引发异常 *os.rmdir(path, , dir_fd=None)： 删除目录 # import os os.rmdir(\u0026#39;/path/to/directory_to_remove\u0026#39;) # 删除指定目录 os.removedirs(path)： 递归地删除目录 # import os os.removedirs(\u0026#39;/path/to/directory_to_remove\u0026#39;) # 递归地删除指定目录及其上级目录（如果为空） *os.remove(path, , dir_fd=None)： 删除文件 # import os os.remove(\u0026#39;/path/to/file_to_remove\u0026#39;) # 删除指定文件 *os.rename(src, dst, , src_dir_fd=None, dst_dir_fd=None)： 重命名文件或目录 # import os os.rename(\u0026#39;/path/to/old_name\u0026#39;, \u0026#39;/path/to/new_name\u0026#39;) # 重命名文件或目录 os.path.exists(path)： 检查文件或目录是否存在 # import os exists = os.path.exists(\u0026#39;/path/to/file_or_directory\u0026#39;) # 检查文件或目录是否存在 os.path.isfile(path)： 检查路径是否为文件 # import os is_file = os.path.isfile(\u0026#39;/path/to/file\u0026#39;) # 检查路径是否为文件 os.path.isdir(path)： 检查路径是否为目录 # import os is_directory = os.path.isdir(\u0026#39;/path/to/directory\u0026#39;) # 检查路径是否为目录 os.path.join(path1, path2, \u0026hellip;)： 拼接路径 # import os full_path = os.path.join(\u0026#39;/path/to\u0026#39;, \u0026#39;file_or_directory\u0026#39;) # 拼接路径，得到 \u0026#39;/path/to/file_or_directory\u0026#39; os.path.abspath(path)： 获取绝对路径 # import os absolute_path = os.path.abspath(\u0026#39;relative_path\u0026#39;) # 获取相对路径对应的绝对路径 Datetime(日期和时间) # now()： 获取当前日期和时间 # from datetime import datetime now = datetime.now() strptime(date_string, format)： 将字符串转换为日期时间对象 # from datetime import datetime date_str = \u0026#39;2023-01-01\u0026#39; date_format = \u0026#39;%Y-%m-%d\u0026#39; date_obj = datetime.strptime(date_str, date_format) strftime(format)： 将日期时间对象格式化为字符串 # formatted_date = date_obj.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) date()： 获取日期部分 # date_part = date_obj.date() time()： 获取时间部分 # time_part = date_obj.time() year： 获取年份 # year = date_obj.year month： 获取月份 # month = date_obj.month day： 获取日期 # day = date_obj.day hour： 获取小时 # hour = date_obj.hour minute： 获取分钟 # minute = date_obj.minute second： 获取秒数 # second = date_obj.second timestamp()： 将日期时间对象转换为 POSIX 时间戳 # timestamp = date_obj.timestamp() fromtimestamp(timestamp)： 将 POSIX 时间戳转换为日期时间对象 # from_timestamp = datetime.fromtimestamp(timestamp) timedelta(days, seconds, microseconds)： 表示两个日期时间对象之间的差异 # difference = date_obj1 - date_obj2 JSON # dumps(obj, indent=None, separators=None, default=None, sort_keys=False)： 将 Python 对象转换为 JSON 字符串 # import json data = {\u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} json_str = json.dumps(data, indent=2, sort_keys=True) loads(s, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None)： 将 JSON 字符串转换为 Python 对象 # import json json_str = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\u0026#39; python_obj = json.loads(json_str) **dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, kw)： 将 Python 对象写入 JSON 文件 # import json data = {\u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} with open(\u0026#39;data.json\u0026#39;, \u0026#39;w\u0026#39;) as json_file: json.dump(data, json_file, indent=2, sort_keys=True) **load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, kw)： 从 JSON 文件中读取数据并返回 Python 对象 # import json with open(\u0026#39;data.json\u0026#39;, \u0026#39;r\u0026#39;) as json_file: python_obj = json.load(json_file) JSONEncoder.default(o)： JSON 编码器的默认方法，用于处理不可序列化的对象 # class MyEncoder(json.JSONEncoder): def default(self, o): if isinstance(o, MyCustomClass): return o.__dict__ return super().default(o) data = {\u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;custom_obj\u0026#39;: MyCustomClass()} json_str = json.dumps(data, cls=MyEncoder) JSONDecoder.object_hook(d)： JSON 解码器的默认方法，用于处理对象字典 # class MyDecoder(json.JSONDecoder): def object_hook(self, d): if \u0026#39;custom_obj\u0026#39; in d: return MyCustomClass(**d[\u0026#39;custom_obj\u0026#39;]) return d json_str = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;custom_obj\u0026#34;: {\u0026#34;property1\u0026#34;: \u0026#34;value1\u0026#34;, \u0026#34;property2\u0026#34;: \u0026#34;value2\u0026#34;}}\u0026#39; python_obj = json.loads(json_str, cls=MyDecoder) Time # time()： 返回当前时间的时间戳（1970纪元后经过的浮点秒数） # import time timestamp = time.time() sleep(secs)： 推迟调用线程的运行，secs指秒数 # import time print(\u0026#34;Start\u0026#34;) time.sleep(2) # 暂停2秒 print(\u0026#34;End\u0026#34;) localtime([secs])： 将秒数转换为表示当地时间的 struct_time，secs为可选参数，默认为当前时间戳 # import time local_time = time.localtime() strftime(format, t)： 格式化表示时间的字符串，format为格式化字符串，t为可选参数，默认为当前时间 # import time formatted_time = time.strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;, time.localtime()) strptime(string, format)： 将格式化字符串转换为 struct_time # import time time_string = \u0026#34;2023-01-01 12:00:00\u0026#34; structured_time = time.strptime(time_string, \u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) mktime(t)： 将 struct_time 转换为秒数 # import time structured_time = time.localtime() timestamp = time.mktime(structured_time) clock()： 返回自程序开始以来的CPU时间，包含了睡眠时间 # import time start_time = time.clock() # 执行一些任务 end_time = time.clock() elapsed_time = end_time - start_time process_time()： 返回当前进程的系统和用户CPU时间的总和 # import time start_time = time.process_time() # 执行一些任务 end_time = time.process_time() elapsed_time = end_time - start_time "},{"id":11,"href":"/posts/%E6%9D%82%E6%80%9D/%E4%B8%80%E5%B8%A6%E4%B8%80%E8%B7%AF/","title":"一带一路","section":"杂思","content":"你好，这是Bing。我很高兴你对“一带一路”有哪些影响感兴趣。😊\n“一带一路”是中国政府于2013年提出的一项跨国经济合作倡议，旨在沿着古代丝绸之路和海上丝绸之路，加强亚欧非大陆及附近海洋的互联互通，促进沿线国家的共同发展繁荣。\n“一带一路”对中国和沿线国家的经济发展有以下几个方面的影响：\n提升国际地位：通过推动“一带一路”的实施，中国在全球经济治理中的地位得到了进一步提升，成为全球经济发展的重要推动者 1。 扩大对外投资：“一带一路”鼓励中国企业走出去，投资沿线国家的基础设施建设和产业项目，为中国企业提供了更多的海外市场机会 2。 增加贸易往来：“一带一路”通过降低贸易壁垒、加强海关合作和优化贸易流程，促进沿线国家之间的贸易发展，有利于中国扩大对外贸易规模 2。 优化产业结构：中国企业参与“一带一路”沿线国家的投资和建设，有助于推动中国产业结构的优化升级，提高中国经济的竞争力 2。 提高就业水平：随着中国企业走出去，投资沿线国家的基础设施建设和产业项目，为中国的劳动力市场提供了更多的就业机会 2。 促进沿线国家经济发展：“一带一路”为沿线国家提供了丰富的资金、技术和管理经验，有助于提高沿线国家的基础设施水平、增加就业机会、提高人民生活水平，从而促进沿线国家的经济发展 3 1。 加强区域合作：“一带一路”通过加强政策沟通、设施联通、贸易畅通、资金融通和民心相通，推动区域一体化，有利于形成一个更加紧密的经济合作体 3 1。 推动科技创新：“一带一路”下的基础设施建设、能源合作等项目，需要大量的先进技术，这将推动科技创新和研发，从而提升中国及相关国家的科技水平 3 4。 提升人民福祉：通过“一带一路”的实施，中国与沿线国家在教育、医疗、文化等领域的合作不断加强，有助于提高人民福祉 3 4。 以上是我为你介绍的“一带一路”有哪些影响的相关信息，如果你想了解更多详情，请点击相应的链接。谢谢你使用Bing聊天模式。👋\n"},{"id":12,"href":"/posts/%E6%9D%82%E6%80%9D/%E4%BF%A1%E6%81%AF%E5%8F%82%E8%80%83/","title":"信息参考","section":"杂思","content":" low high 悲观 乐观 紧张 放松 怀疑 自信 懒惰 勤劳 内向 外向 疲惫 兴奋 麻烦 方便 伤心 开心 肮脏 干净 虚假 真实 失败 胜利 轻盈 沉重 善变 稳定 冷淡 热烈 异常 正常 模糊 清晰 狭窄 宽阔 短暂 长久 温和 强硬 小气 大方 分离 统一 "},{"id":13,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E4%BF%AE%E8%BA%AB/","title":"修身","section":"个人","content":" 内在 # 主要 # 11 点前睡觉 次要 # 不在手机上刷短视频 多看书 408科目复习 刷算法题 外在 # 主要 # 骑车回去 次要 # 20 个俯卧撑 100 个单腿,左50,右50 穿好衣服,整理仪容仪表 每天 6000 步 "},{"id":14,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E5%85%B3%E4%BA%8E%E5%81%9A%E4%BA%8B/","title":"关于做事","section":"个人","content":" 发展 # 发展才能解决一切问题 悲观和乐观 # 悲观带来怀疑、沮丧、恐惧、绝望、焦虑和抑郁，乐观带来坚定、韧性、勇气、希望、开朗和阳光\n尝试 # 做事情就像搭建木，前期可以大胆尝试，坍塌的代价不过几块小积木而已，后期则必须小心翼翼，不然花费很多时间的高楼将重头再来搭建。 在当下，大部分事情是无意义且有害的 当下找不到意义的事情，影响往往是长远的 多去说话，弥补自己说话吞吞吐吐的缺点 做了总比不做好 休息 # 闲下来充分休息，不要忙得没时间思考 态度 # 因地制宜,因时制宜,什么时候就做应该做的事情\n逆水行舟，不进则退\n忌讳是懒惰，绝对不要拖延症\n慢工出细活\n凡事预则立，不预则废，没有准备的事情失败是应该的，顺利则是侥幸\n为长远记，目光短浅是会患得患失的，是会后悔的\n注意边际效应\n"},{"id":15,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E5%85%B3%E4%BA%8E%E7%9D%A1%E8%A7%89/","title":"关于睡觉","section":"个人","content":" 喝牛奶 晒太阳（促进褪黑素分泌） 晚上10点半以后不看手机 不焦虑 多听音乐 "},{"id":16,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E5%85%B3%E4%BA%8E%E7%AF%AE%E7%90%83/","title":"关于篮球","section":"个人","content":"健壮的身体和娴熟的技术\n关于投篮 动作要点: 调整脚步,左脚在前,右脚在后 想象下面有个凳子坐下去,接着像弹簧一样起来 辅助手确定最左出手范围，控制方向 直臂出手,打直手腕 手指拨球,压腕让球保持高度和旋速 保持投篮动作 目标是弧度尽量高，发力尽量轻松 要往上发力投篮，就要往下下面压，下半身和上半身要发力不脱节 投篮手不要抓球，食指和中指张开，压腕时合拢 辅助手确定投篮范围，控制方向 在脚发力完成之前， 投篮夹角＜90度 投篮弧度要是一个抛物线，高度要高于篮板上沿 几个重要的指标：球旋速、球高度 关于上篮 果冻上篮，手心正对着篮板，旋球到篮板的左上角或者右上角 多观察全局位置 攻击前侧脚 关于运球 减少运球时间 只突破不经常终结，多多分球 踮脚尖走路能锻炼小腿肌肉和踝关节稳定性。 一直收肚子能减少身体负担 "},{"id":17,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E5%85%B4%E8%B5%B7/","title":"兴起","section":"个人","content":" 首页美化计划 # 目的是增强博客的丰富度和内容,使得博客不再那么枯燥无味,并进一步将个人数据透明化和可视化\n步骤如下\n初步利用网页组件美化 搞定数据的存储和传输 图表可视化 万物皆有定数 # 方式: 系统api/相关软件/自行记录\n数据格式: JSON\n内容: 与我有关的所有数据,单位为天\n步数 睡眠时长, 睡眠起始点 键盘输入字符数量 \\ 鼠标点击次数 饮水量 \\ 吃饭内容 洗澡 \\ 洗头 购物记录 重要的定数 计算力 记忆力 意志力 一言 # 介绍 # 在息屏或者锁屏状态下显示一段话,可以运行在移动端或者PC端,每隔一定的时间按照某种顺序来切换另一段话,数据接口可以为本地或网络上的.JSON文件和.CSV文件等.\n待定计划 # 短信应用开发 移动端和PC端应用开发 参考内容 # http://blog.lwons.com/archieve/3_entity_search_databases.html https://languageresources.github.io/2018/03/07/%E8%8B%97%E8%8F%81%E8%8F%81_Wikidata%E7%9F%A5%E8%AF%86%E5%BA%93/ https://www.wikidata.org/w/api.php?action=wbsearchentities\u0026search=Fudan\u0026language=en\u0026limit=20\u0026format=json Wikipedia json数据 https://dumps.wikimedia.org/wikidatawiki/entities/ 有书可读方案 # 电子书 下载到本地 优秀的阅读体验 个人存储方案 # NAS\n好处在于可扩展存储，数据安全，价格也不算特别高\n坏处在于速度和可用性需要网络支持，需要内网穿透或者公网IP，且需要24小时开启，费电\nType-C U盘\n好处在于速度有保障、不需要依赖网络\n坏处在于用时候没法充电，容易丢失，带来发热量，价格略贵\nSD 卡 存储\n好处在于速度有保障、不需要依赖网络\n坏处在于容易丢失，带来发热量，价格贵\n网络云盘（阿里云盘等）\n好处在于可扩展存储，数据安全，价格也不算特别高\n坏处在于速度和可用性需要运营商支持，一般来说，速度都比较慢\n最后总结一下,四个存储方案,供大家参考\n价格 读写速度 可扩展性 稳定性 其他问题 NAS 硬盘便宜,NAS本身贵,网费和电费月支 网速 多块硬盘 极其稳定 Type-C U盘 价格 SD 卡存储 网络云盘(阿里云盘等) "},{"id":18,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E5%BA%94%E7%94%A8%E5%B1%82-qa/","title":"应用层-Q\u0026A","section":"理论知识","content":"应用层是指电脑上各种应用软件进程通过何种应用层协议来使用网络提供的通信服务\n域名系统DNS是什么 # 域名系统是指 Internet 中用于把主机名字转换成IP的系统\n为啥 IP 数据包不使用域名而是用 IP 地址呢 # 因为 IP 地址的长度是固定的32位或者固定的128位，而域名的长度是可变的\n域名服务器DNS使用频率非常高，如何解决域名服务器可能出现的故障问题呢 # 域名服务器DNS被设计成联机分布式数据系统，采用B/S架构, 大多域名在本地进行解析,少量解析需要通过互联网.\n域名到IP地址的解析过程是怎么样的呢 # 当应用需要将域名转 IP 地址时, 应用就调用解析程序( resolver ), 把待解析的域名放在 DNS 请求报文中, 以 UDP 方式发送给本地域名服务器,本地服务查找域名之后, 把对应的 IP 地址发送给应用主机.\n域名是怎么组成的呢 # 早期是无层次的名字空间, 后来因为用户数量急剧增加, 管理这个域名集合空间非常困难, 互联网才用了层次树状结构的命名方法, 任何在互联网上的主机或者路由器, 都有一个唯一层次结构的名字(即域名)，域名由标号和点组成， 如www.baidu.com，其中com为顶层域名，baidu为二级域名，www为三级域名。\n互联网域名空间是一个倒过来的树状结构，最上面的是根，根下面的第一层是顶级域名，第二层是二级域名，第三层是三级域名，以此类推，最后一层是叶子节点，也就是这主机名字。\n域名中的标号是怎么规定的呢 # 由英文字母和数字组成，不区分大小写，每个标号不超过63个字符（为记忆最好不要超过12个字符）。\n前面提到域名服务器是联机分布式数据系统，那么它是如何分布管理的呢 # 域名服务器采用分区的方法来管理，因为这样相比起按照域名来划分，会使域名服务器的数量太多，使域名系统的运行效率降低。\n区（zone）是指域名服务器负责的范围。\n域名服务器之间的解析过程是怎么样的呢？ # 主机向本地域名服务器查询基本采用递归查询。\n本地域名服务器想根域名服务器采用迭代查询。\n文件传输协议有哪些？ # 文件传输协议包括两种FTP和TFTP协议，FTP基于TCP支持文件传输和交互，而TFTP基于UDP支持文件传输不能交互。\nTELNET 是什么协议？ # TELNET 是一个基于TCP的简单远程终端协议，用于远程登录另一台主机。\nWWW 、HTTP、HTML 是指什么？两者有什么关系 ？ # WWW（World Wide Web）是一个基于HTTP协议的、分布式的、超文本的信息存储系统。\nHTTP （HyperText Transfer Protocol）是一个无状态的、基于TCP的应用层协议。\nURL 的格式？URL 是否区分大小写? # \u0026lt;协议\u0026gt;://\u0026lt;主机\u0026gt;:\u0026lt;端口\u0026gt;/\u0026lt;路径\u0026gt;\n不区分大小写\nHTTP 的传输过程 # 建立 TCP 连接 B发送 请求报文 C发送 响应报文 关闭 TCP 连接 HTTP 的状态码分别代表什么? # 1xx代表通知信息,如何请求收到了或正在处理\n2xx代表成功,如接受或知道了\n3xx代表重定向, 如完成请求还要进一步采取行动\n4xx代表客户端请求错误,如因为客户端输入错误的URL而无法访问\n5xx代表服务器响应错误, 如服务器已关闭连接.\n为什么存在 Cookie 这种东西? # 由于 HTTP 本身是无状态的，但是在一些网站实际业务中不可避免要记住用户的当前状态，如果要记住用户的登录状态，当用户登录成功之后，网站服务器便在响应中设置一个识别码“Set-cookie”，当用户的浏览器收到响应之后，就会将其中的 Cookie 予以保存到本地，并在下次请求时将 Cookie 放到请求头中去。\n"},{"id":19,"href":"/posts/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/","title":"技术记录","section":"  ","content":" hugo 添加mermaid作图 # https://cloud.tencent.com/developer/article/1944123\nCSS 字体 # 在CSS中，font-size属性可以使用多种单位来指定字体大小。以下是一些常见的font-size单位：\n像素（px）：像素是绝对单位，它会直接指定字体的像素大小。例如，font-size: 16px; 将文本字体设置为16像素高。\n磅（pt）：磅是印刷单位，通常用于打印。1磅等于1/72英寸，因此它也可以用于屏幕上的字体大小。例如，font-size: 12pt; 将字体设置为12磅。\n毫米（mm）：毫米是长度单位，也可以用于字体大小。例如，font-size: 5mm; 将字体大小设置为5毫米。\n厘米（cm）：厘米也是长度单位，可以用于指定字体大小。例如，font-size: 0.5cm; 将字体大小设置为0.5厘米。\n百分比（%）：百分比是相对于父元素的大小来定义字体大小。例如，font-size: 150%; 表示字体大小是父元素字体大小的150%。\nem：em单位是相对于当前元素的字体大小来定义的。例如，font-size: 1.5em; 表示字体大小是当前元素字体大小的1.5倍。\nrem：rem单位也是相对于根元素（html元素）的字体大小来定义的。这可以使字体大小在整个文档中保持一致。例如，font-size: 1.2rem; 表示字体大小是根元素字体大小的1.2倍。\n刷机参考 # TWRP刷机 https://zhuanlan.zhihu.com/p/96968140 Magisk 刷入 https://magiskcn.com/ 沸米计划 https://mi.fiime.cn/FiimePlan/24.html#gallery hugo 日期转时间戳 # 原因是这样的,我在设置文章更新时间的时候,大部分的日期转时间戳貌似都没问题,除了当天的时间转时间戳,当时时间为当天的 14 点,出来的时间戳一转成时间,结果居然是 22 点, 不断测试,发现不是我代码的问题.\n多次修改无果,问了chatGPT才知道,转时间戳的过程原来还有其他东西会影响\n在处理时间戳时，有一些需要注意的重要事项, ChatGPT 的回答如下\n时间戳精度： 时间戳可以是秒级或毫秒级的，具体取决于系统和编程语言。确保您清楚时间戳的精度，以免出现错误。\n时区和区域性： 时间戳通常是与协调世界时 (UTC) 相关的。时区和区域性的问题可能会导致时间戳的解释不正确。在处理时间戳时，考虑时区和区域性，以便正确地显示和解释日期时间。\n时间戳格式： 时间戳可以采用不同的格式，包括整数（秒或毫秒）、ISO 8601（例如：2023-10-11T14:44:16Z）等。确保您了解所使用的时间戳格式，以正确解释和显示日期时间。\n4. 溢出和范围： 时间戳的范围是有限的，因此要小心处理超出范围的情况。对于以秒为单位的时间戳，通常范围在约1970年至2038年之间。对于以毫秒为单位的时间戳，范围更大，但仍然有限。\n精确性： 根据时间戳的精度，可能会存在一些精度问题。毫秒级时间戳可以提供更高的精度，但仍然有限。在某些情况下，您可能需要考虑四舍五入或截断精度以满足需求。\n跨时区计算： 如果涉及到多个时区，确保正确进行时区转换。使用合适的工具和库来处理跨时区问题。\n日期时间显示： 在显示时间戳时，考虑最终用户的需求和偏好。提供适当的日期时间格式，并考虑将时间戳转换为本地时区以获得更好的用户体验。\n维护和更新： 时间戳可能需要在未来进行维护和更新，以适应不同的需求或问题。时刻注意更新可能会影响应用程序的行为。\n总之，处理时间戳需要小心，要理解时间戳的精度、格式、时区和区域性，以及如何正确地显示和处理日期时间数据。这可以确保您的应用程序或系统在时间方面表现正确。\nhugo 字段bug # publishDate字段会有时候让文章显示不出来, 或许是 hugo 内部编译执行的过程出错\nfrontmatter: # publishDate: # - datetimeCreate lastmod: - datetimeUpdate git 代理设置和解决 # git config --global https.proxy http://127.0.0.1:1080 git config --global https.proxy https://127.0.0.1:1080 git config --global --unset http.proxy git config --global --unset https.proxy npm config delete proxy 转载 https://gist.github.com/laispace/666dd7b27e9116faece6\n蓝牙音量不正常 # 经常有小伙伴反馈蓝牙耳机音量小的问题，这里科普一下为什么蓝牙耳机音量小？\n蓝牙耳机音量小，无非两种情况:\n1.手机输出音量小\n2.耳机自生音量调节小了\n好比一根水管，有两个阀门，如果其中一个开关调小，流量就会变小，要想全速流淌，必须要把两个开关全部打开。\n很多小伙伴反馈的是手机音量已经调节到最大还是音量小，其实此时手机的输出已经是最大了，要想调大音量，就必须要调节另一个水龙头，此水龙头自然就是蓝牙耳机自己的音量调节开关了。\n但是，为了把耳机做小，现在很多耳机，特别是TWS耳机，经常没有音量调节按钮，此时想要调节耳机音量，就必须要靠杀器 :蓝牙绝对音量 了。\n那么什么是 蓝牙绝对音量呢？其实，绝对音量就相当于给水管的两个水龙头加了一个联动装置，不管调节哪一个开关，两个水龙头都会同步调节，这样就不存在手机音量调节到最大，耳机或者音箱仍然音量小了。\n但是，需要注意的是，绝对音量功能并不是每个耳机都支持的，有个别耳机，音箱，及车机就是不支持绝对音量的（常见于比较老旧的设备及蓝牙芯片），判断耳机是否支持绝对音量的方法是:\n如果耳机自带音量调节按键，在手机开发者选项中开启绝对音量，然后重新连接蓝牙耳机，重连后从耳机上调节音量，如果手机能显示音量进度条，那么此耳机就是支持绝对音量的。反之则耳机不支持绝对音量。\n当然，如果有的耳机一开始可以调节，可是突然有一天，不能同步调节手机音量了，可能是手机记录了某些不规范操作，把此耳机拉黑了，此时可以尝试从手机端解除配对，重新配对的方式看是否能恢复。\n另外，也有可能是耳机自己记录了手机某些信息，将手机拉黑了，此时可以尝试将耳机恢复出厂设置，通常将耳机恢复出厂设置的方法不会写入说明书，你只能联系销售客服，咨询恢复重置耳机的方法，\n例如大多数TWS耳机重置的方法是:\n1.清除手机配对记录：无蓝牙、无TWS连接状态下，长按触控按键15秒（左右耳分别执行）\n2.断开手机连接：连接手机状态下，无音乐播放、无通话，长按主耳机触控按键5秒\n转载 https://www.realmebbs.com/post-details/1245148418070818816\n"},{"id":20,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","title":"数据结构和算法","section":"理论知识","content":" 参考 # https://www.cs.usfca.edu/~galles/visualization/Algorithms\n查找 # 评价指标: # 查找长度(SL) 平均查找长度(ASL):考虑查找成功和失败的平均SL 顺序查找 O(n) # def search_seq(ls,k): for i in range(len(ls)): if k == ls[i]: return i return -1 二分查找 O(Log2n) # def search_bin(ls,k): low = 0 high = len(ls)-1 while low\u0026lt;=high: mid = (high-low)/2 if ls[mid] == k: return mid elif ls[mid]\u0026lt;k: high = mid+1 else: low = mid-1 如果取整为向上(向下),则左子树比右子数量大(小)1个或相等\n排序 # 评价指标 # 稳定性 时间复杂度 空间复杂度 读写次数(外部排序时) 分类 # 数据是否全部在内存中 内部排序:数据都在内存中 外部排序:数据太多,无法全部放入内存中 直接插入排序 # "},{"id":21,"href":"/posts/%E6%AD%8C%E8%AF%8D/%E6%99%9A%E9%A3%8E/","title":"晚风","section":"歌词","content":" 作曲 : Copy/BT07-PZ\n作词 : Copy/BT07-PZ\n编曲：July\n采样：星爷\n混音：XTONE\n将近的晚风快吹干整条小巷\n燃尽的灯光无法再将我们点亮\n要明白有些事情不能总靠想象\n大不了今晚继续喝到明天早上\n看不到希望的人还在自言自语说着\n抱怨得不到温暖的人还在继续作着\n他对着电话那头说着自己过得很好\n挂断之后他又在被子里面偷偷哭了\n不存在一帆风顺 偶尔也会去疯混\n尽管有好多人讨论着你是什么门货\n慢慢也有了分寸 不屑于那些争论\n所以我大多数的时候都会选择沉默\n付出的一切难免最后都会化为落尘\n就算整个世界空绝就剩我独自一人\n感觉到肩上重了 心里又再次痛了\n把委屈偷偷收好索性忘掉那些过程\n一个人漫无目的 迷失在晚风里\n我知道后会无期 但也不能逃避\n迷惘的日子 感谢能遇见你\n究竟还要经历多少荆棘\n也许该为我的选择庆幸\n人活着到底为了什么东西忙碌可能为了一张到老也不够还清的账单\n我每天碌碌无为却又感觉活的累总有人劝我别追梦了快去上班\n混到头来不过为了一个名称\n你喜欢的东西总有许多人争\n他们随便动动手指就能得到的你却要付出百倍努力还要赌上你的人生\n或许被打到鼻青脸肿也不敢还手吧\n你知道后果没有人可以来为你承担\n吃完泡面会撒谎自己的钱还有\n一半是不想被担心一半怕再难堪\n我没有他们那么出众没有开豪车的叔送\n就这样其实我也无所谓\n不就是被骂了两句并不值得你去选择放弃\n听完这首歌就早点睡\n一个人漫无目的 迷失在晚风里\n我知道后会无期 但也不能逃避\n迷惘的日子 感谢能遇见你\n究竟还要经历多少荆棘\n也许该为我的选择庆幸\n你没做怎么知道没搞头\n你不要做了 我劝你要脚踏实地的做人嘛\n这里有份洗厕所的工作你先做着 你就别做梦了\n做人如果没梦想 那跟咸鱼有什么分别啊\n你连鞋都没有 那不就是咸鱼一条喽 还学人家讲理想？\n话不能这么讲 我心中的一团火是不会熄的\n那把它吹熄了 不熄？\n熄了可以再点着它\n"},{"id":22,"href":"/posts/%E6%9D%82%E6%80%9D/%E6%9C%89%E4%B9%A6%E5%8F%AF%E8%AF%BB%E6%96%B9%E6%A1%88/","title":"有书可读方案","section":"杂思","content":" 电子书 下载到本地 优秀的阅读体验 "},{"id":23,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"正则表达式","section":"技术","content":"正则表达式的所有元字符\n正则表达式的所有元字符包括(markdown表格列出来)：\n元字符 描述 . 匹配任意字符（除了换行符） \\d 匹配数字字符 \\D 匹配非数字字符 \\w 匹配单词字符（字母、数字、下划线） \\W 匹配非单词字符 \\s 匹配空白字符（空格、制表符、换行符等） \\S 匹配非空白字符 ^ 匹配字符串的开头 $ 匹配字符串的结尾 * 匹配前面的元素零次或多次 + 匹配前面的元素一次或多次 ? 表示前面的元素是可选的，匹配零次或一次 {n} 表示前面的元素恰好出现 n 次 {n,} 表示前面的元素至少出现 n 次 {n,m} 表示前面的元素出现 n 到 m 次之间 [] 字符集，匹配括号中任意一个字符 [^] 或 [^\u0026hellip;] 否定字符集，匹配除了括号中指定的任意字符之外的其他字符 "},{"id":24,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E6%B8%85%E5%8D%95/","title":"清单","section":"个人","content":" 安卓手机 # 软件 # 小黑屋 appShare Cemiuiler magisk: 苹方字体模块 神仙救砖 LSPosed-zygisk 爱玩机工具箱 ES 文件浏览器 Via 浏览器 b站(带漫游模块) Clash NoActive 手机性能排行 GKD(跳广告) 讯飞输入法: ios Apple music Telegram X Play 商店 MIUI 主题: 遇见IOS (AP景深宠物岛) 主题破解 win # 软件 # QQ 输入法 vscode 图吧工具箱 vivaldi 浏览器 Obsidian autoHotKey ; 将 Lalt 单键映射成ctrl LAlt::LCtrl ; 大写锁定 \u0026gt;\u0026gt; 回车键 CapsLock::Enter ; ` \u0026gt;\u0026gt; 退格键 `:: BackSpace +`::Delete ; F1 \u0026gt;\u0026gt; Home F1:: Home ; F2 \u0026gt;\u0026gt; end F2:: end "},{"id":25,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E7%9B%AE%E6%A0%87/","title":"目标","section":"个人","content":" 长期目标 # 利用chatgpt之类的大模型接入一个语音助手 瘦下来到120斤 保持最佳状态(睡足、吃好) 跳槽准备 短期目标 # 投影仪 计算机网络复习 数据结构复习 英语学习 "},{"id":26,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91/","title":"维基百科","section":"技术","content":"维基百科（Wikipedia）提供了一套API，允许开发者通过HTTP请求来获取和检索维基百科的内容。以下是一些关于维基百科API的基本信息：\n维基百科 API 基本信息 # Endpoint（终端点）： https://en.wikipedia.org/w/api.php （英语维基百科的API终端点，你可以替换 en 为其他语言标识符）\n请求方式： 主要使用HTTP GET请求，但也支持POST请求。\n返回格式： 默认返回JSON格式，也可以选择其他格式，如XML。\n常用维基百科 API 请求参数 # action（动作）： 定义API的行为，常见值包括 query（查询）、parse（解析）、opensearch（开放搜索）等。\nformat（格式）： 指定返回结果的格式，常见值包括 json 和 xml。\ntitles（标题）： 指定要查询的页面标题，可以是单个标题或多个标题。\npageid（页面ID）： 指定要查询的页面的ID，与标题二选一使用。\nprop（属性）： 查询页面的属性，如 revisions（修订版本）、categories（分类）等。\nrvprop（修订版本属性）： 用于指定 revisions 属性的具体内容，如 content（内容）、timestamp（时间戳）等。\nredirects（重定向）： 控制是否将重定向页面包含在结果中。\nlimit（限制）： 用于限制查询结果的数量。\n示例：获取页面内容 # https://en.wikipedia.org/w/api.php?action=query\u0026amp;format=json\u0026amp;titles=Python_(programming_language)\u0026amp;prop=revisions\u0026amp;rvprop=content 这个例子用于获取“Python编程语言”页面的内容。你可以通过修改参数来执行不同的操作和查询其他页面。\n请注意：使用维基百科API时，你可能需要遵循维基百科的使用政策和服务条款。详细的API文档和更多信息可以在 维基百科开发者页面找到。\n"},{"id":27,"href":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/","title":"网站收藏","section":"  ","content":" 学习网站 # 全历史 https://www.allhistory.com 今日热榜 https://tophub.today 知乎日报 https://tophub.today 网络工具 # 科学上网 机场巴巴 http://www.ckcloud.cc 白嫖机场 https://yyds.白嫖.net 机场推荐 http://www.maomeng.cf SMS-activate https://sms-activate.org 内网穿透 https://www.natfrp.com/ jsDelivr * vercel https://cloud.tencent.com/developer/article/1875306 nameSilo https://www.namesilo.com 软件工具 # 画图工具 https://handraw.top Chatgpt https://chat.openai.com hugo https://hugo.aiaide.com/post Lyricify https://github.com/WXRIW/Lyricify-App "},{"id":28,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"计算机网络","section":"理论知识","content":" 应用层 # 应用层协议是为了各应用进程需要不同的通信规则而存在的, 也是要依赖运输层所提供的基本通信服务。\n概念 # 应用层主要包括以下内容\n域名系统 DNS WWW 和 HTTP 协议 电子邮件的相关协议，SMTP 协议和 POP3 协议、IMAP 协议 域名系统 DNS # DNS 的作用是将域名转为IP地址，具体的过程是应用进程调用 resolver（解析程序），发送包含待解析的域名的 DNS 请求报文，通过 UDP 进行再包装发送到本地域名服务器，本地域名服务器搜索以后，把对应的 IP 地址放在回答报文返回。\n域名 # 域名是一个空间概念，可比作一个盒子，最大的一个盒就是顶级域名，再里面的盒子叫做二级域名，再里面的盒子叫做三级域名。\n如www.baidu.com这个域名，从左到右域名等级依次提高，com就是顶级域名，baidu则是二级域名，www是三级域名。\n这些顶级域名和二级域名以及其他等级的域名都是要遵守域名规则\n必须是英文字母或数字，不区分大小写 一个域名长度不超过 63 个字符 所有域名加起来长度 255 个字符 运输层 # TCP 协议 # 特点:面向连接(虚连接);点对点;可靠有序,不丢不重;全双工通信;字节流\n全双工通信:发送缓存和接收缓存\nTCP首部 # 0 8 16 24 31 --------------------------------------------------------------------------- 源端口 | 目的端口 --------------------------------------------------------------------------- 序号(seq) --------------------------------------------------------------------------- 确认号 --------------------------------------------------------------------------- 首部长度|保留|[URG,ACK,PSH,RST,SYN,FIN] |\t接收窗口大小 --------------------------------------------------------------------------- 检验和 | 紧急指针 --------------------------------------------------------------------------- 选项(长度可变) | 填充 --------------------------------------------------------------------------- 图 TCP的报文段首部 说明: 1.TCP首部总长为21B(20B固定,1B占位),第一行总长度都是4B(32位), `|`表示所占区分割线,如源端口所占为[0,16]的区域 2. 序号(seq):在TCP连接的字节流中,报文段中第一个字节的序号 确认号: 下一个要收报文段的序号, 序号为N, 则序号到N-1的数据都已收到 首部长度:表示TCP首部的长度,单位为4B URG:紧急位,调整报文段优先级 ACK: TCP连接之后,ACk=1,标识为有效报文 PSH: 不需要等发送缓存填满才发 SYN: 标识为同步报文 FIN: 标识为终止报文 接收窗口大小:能够接收窗口的大小 检验和:检验首部+数据,检验要加12B伪首部,第四个字段为6 紧急指针: URG=1才有意义,紧急数据的字节数 选项: 最大报文长度MSS, 窗口扩大,时间戳 三次握手(连接) # B -------[SYN=1,seq=x]----------------------\u0026gt;\u0026gt; S B \u0026lt;\u0026lt;-------[SYN=1, ACK=1,seq=y,ack=x+1]------- S # S分配缓存和变量 B -------[ACK=1,seq=x+1,ack=y+1]------------\u0026gt;\u0026gt; S # B分配缓存和变量,可携带数据 四次挥手(断开) # B -------[FIN=1,seq=x]-------------------\u0026gt;\u0026gt; S # 停止发送,断开连接 B \u0026lt;\u0026lt;--------------[ACK=1,seq=y,ack=x+1]---- S # 确认关闭 B \u0026lt;\u0026lt;----[FIN=1,ACK=1,seq=z,ack=x+1]-------- S # 断开连接 B -------[ACK=1,seq=x+1,ack=z+1]---------\u0026gt;\u0026gt; S # 确认关闭,最长报文段寿命2MSL结束,两者连接彻底关闭 可靠传输 # 检验 序号 确认 重传:超时,冗余确认 等待重传 # ACK 冗余确认\n流量控制 # 特点:局部出发,控制速率\nTCP 会利用滑动窗口机制实现流量控制,根据接收缓存的大小,动态改变发送方的发送窗口\n发送窗口 = Min(接收窗口rwnd,拥塞窗口cwnd)\n拥塞控制 # 特点:点对点,全局出发,控制总量\n条件:对资源需求 \u0026gt; 可用资源\n目的是防止过多的数据注入到网络中\n接收窗口:接收方根据接收缓存设置的值,并告诉发送方,反映接收方容量\n拥塞窗口:发送方根据估算网络拥塞程度设置的值,反映网络容量\n慢开始,拥塞避免:(cwnd)指数增长-\u0026gt;sshrend-\u0026gt;线性增长-\u0026gt;0,接着重复该过程\n快重传,快恢复:慢开始的改进,最后一步-\u0026gt;(sshrend/2)\n"},{"id":29,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E8%BF%90%E8%BE%93%E5%B1%82-qa/","title":"运输层-Q\u0026A","section":"理论知识","content":" 运输层是干啥的？为啥会有运输层 # 运输层是为进程与进程之间通信服务用的，规定了进程与进程之间应该以何种协议进行传输数据。\n如果没有运输层，通信数据的传输将不可靠稳定，从而影响整个网络的通信速度质量。\n运输层包括哪些协议内容？这些协议内容有哪些异同点？ # 运输层主要包括TCP【传输控制协议】协议和UDP【用户数据报协议】协议。\n不同点：\nUDP 不需要建立连接直接发送数据包，TCP需要进行三次握手再发送数据 UDP支持一对一、一对多、多对一、多对多的相互通信，TCP支持一对一的点对点通信 UDP不保证数据传输能顺利抵达目的，TCP通过一些内部协议来保证数据传输的一定抵达目的 TCP 协议的三次握手四次挥手过程是怎么样的？ # 三次握手是指客户端和服务端之间建立连接的过程，而四次挥手则是两者释放连接的过程。\n第一次握手：客户向服务端主动发送信号【SYN】，具体内容为我已经准备好同步了，如果你要开始与同步，发送一个确认码ack给我（Acknowledge number，值我发送的随机码+1），代表你真的收到我发的东西了。\n"}]