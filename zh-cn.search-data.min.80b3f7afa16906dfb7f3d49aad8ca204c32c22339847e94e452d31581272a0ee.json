[{"id":0,"href":"/posts/%E4%B8%AA%E4%BA%BA/","title":"个人","section":"  ","content":"写，就是为了记住。\n忘记过去就是背叛，不要忘记，不要悲伤\n明天是上帝给你的礼物，要好好珍惜。\n9e765-1576d\nd2d6f-7e6b7\n7af4a-a7d63\ne879b-5812e\na2559-68288\n4e19c-0cd14\n8638e-51266\n6016c-5fa8a\n81f85-ca821\ne52ba-02d72\n322c5-d4e27\n1eec4-b714c\n1e460-7f1bf\n7ea73-220d4\n37c5a-929a8\nbeea2-77bce\n"},{"id":1,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/","title":"技术","section":"  ","content":"写，就是为了记住。\n忘记过去就是背叛，不要忘记，不要悲伤\n明天是上帝给你的礼物，要好好珍惜。\n"},{"id":2,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/","title":"理论知识","section":"  ","content":"写，就是为了记住。\n忘记过去就是背叛，不要忘记，不要悲伤\n明天是上帝给你的礼物，要好好珍惜。\n"},{"id":3,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E8%80%83%E5%85%AC/","title":"考公","section":"理论知识","content":" 总题量与分值 行测-90分-90题-100分 言表-15道-13分 数关-15道-18分 判推-40道-42分 常识-15道-9分 资分-15道-18分 申论-3小时-5题-100分 行测 言表 主题词 中心题 标题题 细节题 方法 关联词(找重点)-转折重点折后,因果在果后,条件是重点,并列是概括 主题词-排除无主题词选项 文构-总分在前,分总在后,总分总在中 避陷阱-无中生有,偷换概念,偷换逻辑,不符文意 非主题词 排序题 首-下定义,背景引入 中-代词,关联词,逻辑 尾,结论 句空题 首-概括,引入 中,承上启下 尾,结论 词空题 词义-侧重,搭配,程度,褒贬 语境-转折,因果,并列 "},{"id":4,"href":"/posts/","title":"  ","section":"好记性不如烂笔头","content":"写，就是为了记住。\n忘记过去就是背叛，不要忘记，不要悲伤\n明天是上帝给你的礼物，要好好珍惜。\n"},{"id":5,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/git%E6%93%8D%E4%BD%9C/","title":"git操作","section":"技术","content":" 覆盖本地 git fetch origin git reset --hard origin/\u0026lt;branch_name\u0026gt; "},{"id":6,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/hugo-%E5%8F%82%E8%80%83/","title":"Hugo 参考","section":"技术","content":" 变量 .Site #️⃣ .AllPages: 所有页面的数组。 #️⃣ .BaseURL: 站点的基本 URL。 #️⃣ .BuildDrafts: 一个布尔值（默认为 false），指示是否构建草稿。 #️⃣ .Config: 站点的配置。 #️⃣ .Copyright: 网站的版权信息。 #️⃣ .Data: 网站的自定义数据。 #️⃣ .DisqusShortname: Disqus 短代码的 shortname。 #️⃣ .GetPage: 获取指定路径的页面。 #️⃣ .GoogleAnalytics: Google Analytics 的跟踪代码。 #️⃣ .Home: 网站的首页信息。 #️⃣ .IsDevelopment: 当前是否处于开发模式。 #️⃣ .IsMultiLingual: 网站是否支持多语言。 #️⃣ .IsServer: 当前是否处于服务器模式。 #️⃣ .Language: 当前网站的语言。 #️⃣ .LanguagePrefix: 语言前缀。 #️⃣ .Languages: 网站支持的语言列表。 #️⃣ .LastChange: 最近一次修改的日期。 #️⃣ .Lastmod: 最后修改的日期。 #️⃣ .MainSections: 主要部分列表。 #️⃣ .Menus: 网站的菜单列表。 #️⃣ .Pages: 网站的所有页面集合。 #️⃣ .Param: 获取指定参数的值。 #️⃣ .Params: 网站的所有参数。 #️⃣ .RegularPages: 常规页面的集合。 #️⃣ .Sections: 网站的所有部分。 #️⃣ .Sites: Hugo 多站点配置。 #️⃣ .Taxonomies: 网站的所有分类和标签信息。 #️⃣ .Title: 网站的标题。 .Page #️⃣ .Aliases: 页面的别名。 #️⃣ .AllTranslations: 页面的所有翻译版本。 #️⃣ .AlternativeOutputFormats: 页面的所有替代输出格式。 #️⃣ .Ancestors: 页面的祖先页面。 #️⃣ .BundleType: 页面的捆绑类型。 #️⃣ .CodeOwners: 页面的代码所有者。 #️⃣ .CurrentSection: 页面所在的当前部分。 #️⃣ .Data: 页面的数据。 #️⃣ .Date: 页面的日期。 #️⃣ .Description: 页面的描述。 #️⃣ .Draft: 页面是否为草稿。 #️⃣ .Eq: 页面是否等于指定的条件。 #️⃣ .ExpiryDate: 页面的到期日期。 #️⃣ .File: 页面的文件。 #️⃣ .FirstSection: 页面的第一个部分。 #️⃣ .Fragments: 页面的片段。 #️⃣ .FuzzyWordCount: 页面的模糊字数统计。 #️⃣ .GetPage: 获取指定路径的页面。 #️⃣ .GetTerms: 获取页面上指定参数的术语。 #️⃣ .GitInfo: 页面的 Git 信息。 #️⃣ .HasMenuCurrent: 页面是否具有当前菜单。 #️⃣ .HasShortcode: 页面是否包含指定的短代码。 #️⃣ .HeadingsFiltered: 过滤后的页面标题。 #️⃣ .InSection: 页面是否在指定的部分中。 #️⃣ .IsAncestor: 页面是否为指定页面的祖先。 #️⃣ .IsDescendant: 页面是否为指定页面的后代。 #️⃣ .IsHome: 页面是否为首页。 #️⃣ .IsMenuCurrent: 页面是否为当前菜单。 #️⃣ .IsNode: 页面是否为节点。 #️⃣ .IsPage: 页面是否为页面。 #️⃣ .IsSection: 页面是否为部分。 #️⃣ .IsTranslated: 页面是否已翻译。 #️⃣ .Keywords: 页面的关键词。 #️⃣ .Kind: 页面的类型。 #️⃣ .Language: 页面的语言。 #️⃣ .Lastmod: 页面的最后修改日期。 #️⃣ .Layout: 页面的布局。 #️⃣ .Len: 页面的长度。 #️⃣ .LinkTitle: 页面的链接标题。 #️⃣ .Next: 页面的下一个页面。 #️⃣ .NextInSection: 页面的下一个部分内的页面。 #️⃣ .OutputFormats: 页面的所有输出格式。 #️⃣ .Page: 页面自身。 #️⃣ .Pages: 页面的集合。 #️⃣ .Paginate: 分页。 #️⃣ .Paginator: 分页器。 #️⃣ .Param: 页面的参数。 #️⃣ .Params: 页面的所有参数。 #️⃣ .Parent: 页面的父级页面。 #️⃣ .Path: 页面的路径。 #️⃣ .Permalink: 页面的永久链接。 #️⃣ .Plain: 页面的纯文本内容。 #️⃣ .PlainWords: 页面的纯文本内容（按单词切割）。 #️⃣ .Prev: 页面的上一个页面。 #️⃣ .PrevInSection: 页面的前一个部分内的页面。 #️⃣ .PublishDate: 页面的发布日期。 #️⃣ .RawContent: 页面的原始内容。 #️⃣ .ReadingTime: 页面的阅读时间。 #️⃣ .Ref: 页面的引用。 #️⃣ .RegularPages: 页面的常规页面集合。 #️⃣ .RegularPagesRecursive: 页面的递归常规页面集合。 #️⃣ .RelPermalink: 页面的相对永久链接。 #️⃣ .RelRef: 页面的相对引用链接。 #️⃣ .Render: 页面的渲染。 #️⃣ .RenderShortcodes: 渲染短代码。 #️⃣ .RenderString: 渲染字符串。 #️⃣ .Resources: 页面的资源。 #️⃣ .Scratch: 页面的 Scratch。 #️⃣ .Section: 页面所属的部分。 #️⃣ .Sections: 页面的所有部分。 Duration #️⃣ .Abs(): 返回持续时间的绝对值。 #️⃣ .Hours(): 返回持续时间的小时部分。 #️⃣ .Microseconds(): 返回持续时间的微秒部分。 #️⃣ .Milliseconds(): 返回持续时间的毫秒部分。 #️⃣ .Minutes(): 返回持续时间的分钟部分。 #️⃣ .Nanoseconds(): 返回持续时间的纳秒部分。 #️⃣ .Round(): 返回最接近的持续时间，以指定的单位进行四舍五入。 #️⃣ .Seconds(): 返回持续时间的秒部分。 #️⃣ .Truncate(): 返回指定单位的持续时间的整数部分。 .Pages #️⃣ .ByDate(): 根据日期对页面进行排序。 #️⃣ .ByExpiryDate(): 根据到期日期对页面进行排序。 #️⃣ .ByLanguage(): 根据语言对页面进行排序。 #️⃣ .ByLastmod(): 根据最后修改日期对页面进行排序。 #️⃣ .ByLength(): 根据页面内容长度对页面进行排序。 #️⃣ .ByLinkTitle(): 根据链接标题对页面进行排序。 #️⃣ .ByParam(): 根据指定参数对页面进行排序。 #️⃣ .ByPublishDate(): 根据发布日期对页面进行排序。 #️⃣ .ByTitle(): 根据标题对页面进行排序。 #️⃣ .ByWeight(): 根据权重对页面进行排序。 #️⃣ .GroupBy(): 根据指定的关键字对页面进行分组。 #️⃣ .GroupByDate(): 根据日期对页面进行分组。 #️⃣ .GroupByExpiryDate(): 根据到期日期对页面进行分组。 #️⃣ .GroupByLastmod(): 根据最后修改日期对页面进行分组。 #️⃣ .GroupByParam(): 根据指定参数对页面进行分组。 #️⃣ .GroupByParamDate(): 根据指定参数的日期对页面进行分组。 #️⃣ .GroupByPublishDate(): 根据发布日期对页面进行分组。 #️⃣ .Len(): 返回页面集合的长度。 #️⃣ .Limit(): 限制页面集合的长度。 #️⃣ .Next(): 返回页面集合中指定页面的下一个页面。 #️⃣ .Prev(): 返回页面集合中指定页面的上一个页面。 #️⃣ .Related(): 返回页面集合中指定页面的相关页面。 #️⃣ .Reverse(): 对页面集合进行逆序排序。 Time #️⃣ .Add(): 将持续时间添加到时间上。 #️⃣ .AddDate(): 将指定的年、月、日添加到时间上。 #️⃣ .After(): 检查时间是否在另一个时间之后。 #️⃣ .Before(): 检查时间是否在另一个时间之前。 #️⃣ .Day(): 返回时间的日部分。 #️⃣ .Equal(): 检查两个时间是否相等。 #️⃣ .Format(): 格式化时间为指定的字符串格式。 #️⃣ .Hour(): 返回时间的小时部分。 #️⃣ .IsDST(): 检查时间是否处于夏令时。 #️⃣ .IsZero(): 检查时间是否为零值。 #️⃣ .Local(): 将时间转换为本地时区。 #️⃣ .Minute(): 返回时间的分钟部分。 #️⃣ .Month(): 返回时间的月份部分。 #️⃣ .Nanosecond(): 返回时间的纳秒部分。 #️⃣ .Round(): 四舍五入时间到指定的时间单位。 #️⃣ .Second(): 返回时间的秒部分。 #️⃣ .Sub(): 计算两个时间之间的持续时间。 #️⃣ .Truncate(): 将时间截断到指定的时间单位。 #️⃣ .Unix(): 返回时间的 UNIX 时间戳。 #️⃣ .UnixMicro(): 返回时间的微秒精度的 UNIX 时间戳。 #️⃣ .UnixMilli(): 返回时间的毫秒精度的 UNIX 时间戳。 #️⃣ .UnixNano(): 返回时间的纳秒精度的 UNIX 时间戳。 #️⃣ .UTC(): 将时间转换为协调世界时（UTC）。 #️⃣ .Weekday(): 返回时间所在的星期几。 #️⃣ .Year(): 返回时间的年份部分。 #️⃣ .YearDay(): 返回时间在年份中的天数。 方法 math #️⃣ math.Abs: 返回数字的绝对值 $absResult := math.Abs -10.5 #️⃣ math.Add: 将两个数字相加 $addResult := math.Add 5 3 #️⃣ math.Ceil: 返回不小于 x 的最小整数 $ceilResult := math.Ceil 4.2 #️⃣ math.Counter: 返回一个计数器函数 $counter := math.Counter #️⃣ math.Div: 将两个数字相除 $divResult := math.Div 10 2 #️⃣ math.Floor: 返回不大于 x 的最大整数 $floorResult := math.Floor 4.8 #️⃣ math.Log: 返回以 e 为底的对数 $logResult := math.Log math.E #️⃣ math.Max: 返回一组数字中的最大值 $maxResult := math.Max 10 20 30 #️⃣ math.Min: 返回一组数字中的最小值 $minResult := math.Min 10 20 30 #️⃣ math.Mod: 返回两个数字相除的余数 $modResult := math.Mod 10 3 #️⃣ math.ModBool: 返回两个数字相除的余数是否为零 $modBoolResult := math.ModBool 10 5 #️⃣ math.Mul: 将两个数字相乘 $mulResult := math.Mul 5 3 #️⃣ math.Pow: 返回 x 的 y 次方 $powResult := math.Pow 2 3 #️⃣ math.Product: 返回一组数字的乘积 $productResult := math.Product 2 3 4 #️⃣ math.Rand: 返回一个随机数 $randResult := math.Rand #️⃣ math.Round: 返回浮点数的四舍五入值 $roundResult := math.Round 4.5 #️⃣ math.Sqrt: 返回数字的平方根 $sqrtResult := math.Sqrt 25 #️⃣ math.Sub: 返回两个数字的差 $subResult := math.Sub 10 5 #️⃣ math.Sum: 返回一组数字的总和 $sumResult := math.Sum 1 2 3 4 5 .Page "},{"id":7,"href":"/moments/lfeng/","title":"lfeng","section":"Moments","content":" 耐心是生活的关键 2024-04-10 @@@ 成功完成微信朋友圈的模仿 \\images\\personal\\other\\Pasted image 20240401181601.png 2024-04-01 @@@ 好记性不如烂笔头 https://avatars.githubusercontent.com/u/46187375 2024-04-01 "},{"id":8,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/markdown-%E8%AF%AD%E6%B3%95/","title":"markDown 语法","section":"技术","content":" 标题：使用\u0026quot;#\u0026ldquo;字符表示标题，数量代表标题级别，最多支持6级标题。例如：\n# 一级标题 ## 二级标题 ### 三级标题 ... ###### 六级标题 段落：段落之间以空行分隔。\n强调：使用\u0026rdquo;*\u0026ldquo;或\u0026rdquo;_\u0026ldquo;将需要强调的文本包围起来。例如：\n*斜体* _斜体_ **粗体** __粗体__ ***粗斜体*** ___粗斜体___ 列表：有序列表以数字和句点开始，无序列表以\u0026rdquo;*\u0026quot;、\u0026quot;+\u0026ldquo;或\u0026rdquo;-\u0026ldquo;开始。例如：\n1. 第一项 2. 第二项 3. 第三项 - 无序列表项1 - 无序列表项2 - 嵌套的无序列表项 - 更深层次的无序列表项 * 无序列表项A * 无序列表项B * 嵌套的无序列表项 * 更深层次的无序列表项 + 无序列表项X + 无序列表项Y + 嵌套的无序列表项 + 更深层次的无序列表项 链接：使用\u0026rdquo; 链接文本\u0026ldquo;的格式添加链接。例如：\n[Google](https://www.google.com) 图片：使用\u0026rdquo; \u0026ldquo;的格式插入图片。例如：\n![示例图片](https://example.com/image.jpg) 引用：使用\u0026rdquo;\u0026gt;\u0026ldquo;字符表示引用。例如：\n\u0026gt; 这是一段引用的文本。 代码块：使用三个反引号(`)包围代码块，并在开始位置指定代码语言（可选）。例如：\ndef hello_world(): print(\u0026#34;Hello, world!\u0026#34;) 表格：使用\u0026rdquo;|\u0026ldquo;和\u0026rdquo;-\u0026ldquo;分隔表头和表格内容，并使用\u0026rdquo;:\u0026ldquo;来对齐表格内容。例如：\n| 列1标题 | 列2标题 | |---------|---------| | 内容1 | 内容2 | | 内容3 | 内容4 | 左对齐列1标题 | 右对齐列2标题 :------------|-------------: 左对齐内容1 | 右对齐内容2 左对齐内容3 | 右对齐内容4 水平线：使用三个或更多连续的\u0026rdquo;*\u0026quot;、\u0026quot;-\u0026ldquo;或\u0026rdquo;_\u0026ldquo;表示水平线。例如：\n*** --- ___ "},{"id":9,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/python-%E6%96%B9%E6%B3%95%E5%8F%82%E8%80%83/","title":"python 方法参考","section":"技术","content":"以下内容由 ChatGPT 生成, 仅供学习参考\n目录 文件处理（os、io） 网络编程（socket、urllib） 日期和时间处理（datetime、time） 数学运算（math、random） 字符串处理（re、string） 数据结构（list、tuple、dict、set） 对象编程（class、object） 错误处理（try、except） 文件处理（os、io） import os import io #️⃣ os 模块 # 获取和更改当前工作目录 current_directory = os.getcwd() # 返回当前工作目录 os.chdir(\u0026#39;/path/to/directory\u0026#39;) # 改变当前工作目录 # 列出目录内容 contents = os.listdir(\u0026#39;.\u0026#39;) # 列出当前目录中的所有文件和目录 # 创建和删除目录 os.mkdir(\u0026#39;new_directory\u0026#39;) # 创建新目录 os.makedirs(\u0026#39;parent/child_directory\u0026#39;) # 递归创建目录 os.rmdir(\u0026#39;new_directory\u0026#39;) # 删除目录（仅当目录为空时） os.removedirs(\u0026#39;parent/child_directory\u0026#39;) # 递归删除目录 # 删除文件 os.remove(\u0026#39;file.txt\u0026#39;) # 删除文件 os.unlink(\u0026#39;file.txt\u0026#39;) # 删除文件，与 os.remove 功能相同 # 重命名文件或目录 os.rename(\u0026#39;old_name.txt\u0026#39;, \u0026#39;new_name.txt\u0026#39;) # 重命名文件或目录 os.renames(\u0026#39;old_directory\u0026#39;, \u0026#39;new_directory\u0026#39;) # 递归重命名文件或目录 # 文件和目录属性 exists = os.path.exists(\u0026#39;path/to/file_or_directory\u0026#39;) # 检查文件或目录是否存在 is_directory = os.path.isdir(\u0026#39;path/to/directory\u0026#39;) # 检查路径是否为目录 is_file = os.path.isfile(\u0026#39;path/to/file\u0026#39;) # 检查路径是否为文件 size = os.path.getsize(\u0026#39;path/to/file\u0026#39;) # 返回文件大小（字节数） mod_time = os.path.getmtime(\u0026#39;path/to/file\u0026#39;) # 返回文件的最后修改时间 abs_path = os.path.abspath(\u0026#39;path/to/file\u0026#39;) # 返回绝对路径 # 获取文件路径信息 base_name = os.path.basename(\u0026#39;/path/to/file\u0026#39;) # 返回文件名 dir_name = os.path.dirname(\u0026#39;/path/to/file\u0026#39;) # 返回目录名 split_path = os.path.split(\u0026#39;/path/to/file\u0026#39;) # 分割路径为 (目录, 文件名) split_ext = os.path.splitext(\u0026#39;/path/to/file.txt\u0026#39;) # 分割路径为 (文件名, 扩展名) # 访问和修改文件权限 mode = os.stat(\u0026#39;path/to/file\u0026#39;).st_mode # 返回文件权限 os.chmod(\u0026#39;path/to/file\u0026#39;, 0o777) # 修改文件权限 os.chown(\u0026#39;path/to/file\u0026#39;, uid, gid) # 修改文件拥有者 # 目录树遍历 for dirpath, dirnames, filenames in os.walk(\u0026#39;.\u0026#39;): print(f\u0026#39;Found directory: {dirpath}\u0026#39;) for file_name in filenames: print(file_name) # 递归打印当前目录及其子目录中的所有文件 # 获取系统信息 user = os.getlogin() # 返回当前登录用户名 os.environ # 获取系统环境变量 cpu_count = os.cpu_count() # 返回 CPU 核心数量 uname = os.uname() # 返回操作系统信息 linesep = os.linesep # 返回当前平台使用的行终止符 sep = os.sep # 返回当前平台使用的路径分隔符 pathsep = os.pathsep # 返回用于分割文件路径的字符 defpath = os.defpath # 返回默认搜索路径 curdir = os.curdir # 返回当前目录（\u0026#39;.\u0026#39;） pardir = os.pardir # 返回父目录（\u0026#39;..\u0026#39;） # 运行系统命令 os.system(\u0026#39;echo Hello, world!\u0026#39;) # 运行系统命令 output = os.popen(\u0026#39;echo Hello, world!\u0026#39;).read() # 运行系统命令并获取输出 # 创建和管理进程 pid = os.fork() # 创建子进程（Unix） os.execvp(\u0026#39;python\u0026#39;, [\u0026#39;python\u0026#39;, \u0026#39;script.py\u0026#39;]) # 用新的程序替换当前进程 os._exit(0) # 退出进程 # 信号处理 import signal signal.signal(signal.SIGINT, signal.SIG_DFL) # 捕捉和处理信号 # 文件描述符操作 fd = os.open(\u0026#39;file.txt\u0026#39;, os.O_RDONLY) # 打开文件并返回文件描述符 os.read(fd, 100) # 从文件描述符读取数据 os.write(fd, b\u0026#39;Hello, world!\u0026#39;) # 向文件描述符写入数据 os.close(fd) # 关闭文件描述符 # 获取和设置文件偏移量 fd = os.open(\u0026#39;file.txt\u0026#39;, os.O_RDWR) os.lseek(fd, 0, os.SEEK_SET) # 设置文件偏移量 position = os.lseek(fd, 0, os.SEEK_CUR) # 获取文件当前偏移量 # 创建和删除符号链接 os.symlink(\u0026#39;source_file\u0026#39;, \u0026#39;link_name\u0026#39;) # 创建符号链接 os.readlink(\u0026#39;link_name\u0026#39;) # 读取符号链接 os.unlink(\u0026#39;link_name\u0026#39;) # 删除符号链接 # 创建和删除硬链接 os.link(\u0026#39;source_file\u0026#39;, \u0026#39;link_name\u0026#39;) # 创建硬链接 os.unlink(\u0026#39;link_name\u0026#39;) # 删除硬链接 # 获取文件状态 stat_info = os.stat(\u0026#39;file.txt\u0026#39;) # 获取文件状态 stat_info.st_size # 文件大小 stat_info.st_mtime # 文件最后修改时间 # 获取文件系统编码 file_system_encoding = os.getfilesystemencoding() # 返回文件系统编码 # 获取和设置当前进程的优先级 priority = os.getpriority(os.PRIO_PROCESS, os.getpid()) # 获取当前进程的优先级 os.setpriority(os.PRIO_PROCESS, os.getpid(), 10) # 设置当前进程的优先级 # 获取当前进程和父进程 ID pid = os.getpid() # 返回当前进程 ID ppid = os.getppid() # 返回父进程 ID # 获取当前用户 ID 和组 ID uid = os.getuid() # 返回当前用户 ID gid = os.getgid() # 返回当前组 ID # 切换用户 ID 和组 ID os.setuid(uid) # 设置用户 ID os.setgid(gid) # 设置组 ID # 获取当前工作目录的绝对路径 abs_path = os.path.abspath(\u0026#39;.\u0026#39;) # 返回当前工作目录的绝对路径 # 创建命名管道 os.mkfifo(\u0026#39;fifo_name\u0026#39;) # 创建命名管道 # 获取终端尺寸 rows, cols = os.get_terminal_size() # 返回终端行数和列数 # 获取负载平均值 load1, load5, load15 = os.getloadavg() # 返回系统负载平均值 # 判断文件是否为绝对路径 is_abs = os.path.isabs(\u0026#39;/path/to/file\u0026#39;) # 判断是否为绝对路径 # 获取路径的真实路径 real_path = os.path.realpath(\u0026#39;file.txt\u0026#39;) # 返回路径的真实路径 # 更改当前工作目录到用户的主目录 os.chdir(os.path.expanduser(\u0026#39;~\u0026#39;)) # 更改当前工作目录到用户的主目录 # 获取文件或目录的绝对路径 abs_path = os.path.abspath(\u0026#39;file.txt\u0026#39;) # 获取文件或目录的绝对路径 # 返回路径的规范化绝对路径 norm_path = os.path.normpath(\u0026#39;/path/to//file\u0026#39;) # 返回路径的规范化绝对路径 # 返回路径的规范化绝对路径，并解析符号链接 real_path = os.path.realpath(\u0026#39;/path/to/link\u0026#39;) # 返回路径的规范化绝对路径，并解析符号链接 # 获取文件创建时间 ctime = os.path.getctime(\u0026#39;file.txt\u0026#39;) # 获取文件创建时间 # 获取文件最后访问时间 atime = os.path.getatime(\u0026#39;file.txt\u0026#39;) # 获取文件最后访问时间 # 获取文件最后修改时间 mtime = os.path.getmtime(\u0026#39;file.txt\u0026#39;) # 获取文件最后修改时间 # 获取文件大小 size = os.path.getsize(\u0026#39;file.txt\u0026#39;) # 获取文件大小 # 判断路径是否存在 exists = os.path.exists(\u0026#39;file.txt\u0026#39;) # 判断路径是否存在 # 判断路径是否为文件 is_file = os.path.isfile(\u0026#39;file.txt\u0026#39;) # 判断路径是否为文件 # 判断路径是否为目录 is_dir = os.path.isdir(\u0026#39;directory\u0026#39;) # 判断路径是否为目录 # 判断路径是否为符号链接 is_link = os.path.islink(\u0026#39;link\u0026#39;) # 判断路径是否为符号链接 # 扩展用户路径 user_path = os.path.expanduser(\u0026#39;~\u0026#39;) # 扩展用户路径 # 扩展变量路径 var_path = os.path.expandvars(\u0026#39;$HOME\u0026#39;) # 扩展变量路径 # 规范化路径 norm_path = os.path.normpath(\u0026#39;/path/to//file\u0026#39;) # 规范化路径 # 返回路径的绝对路径 abs_path = os.path.abspath(\u0026#39;file.txt\u0026#39;) # 返回路径的绝对路径 # 判断路径是否为绝对路径 is_abs = os.path.isabs(\u0026#39;/path/to/file\u0026#39;) # 判断路径是否为绝对路径 # 分割路径 split_path = os.path.split(\u0026#39;/path/to/file\u0026#39;) # 分割路径为 (目录, 文件名) # 分割路径扩展名 split_ext = os.path.splitext(\u0026#39;file.txt\u0026#39;) # 分割路径为 (文件名, 扩展名) # 拼接路径 join_path = os.path.join(\u0026#39;/path/to\u0026#39;, \u0026#39;file.txt\u0026#39;) # 拼接路径 # 获取路径的基本名 base_name = os.path.basename(\u0026#39;/path/to/file.txt\u0026#39;) # 获取路径的基本名 # 获取路径的目录名 dir_name = os.path.dirname(\u0026#39;/path/to/file.txt\u0026#39;) # 获取路径的目录名 # 判断路径是否为挂载点 is_mount = os.path.ismount(\u0026#39;/mnt\u0026#39;) # 判断路径是否为挂载点 # 获取文件的模式 mode = os.stat(\u0026#39;file.txt\u0026#39;).st_mode # 获取文件的模式 # 获取文件的 inode 编号 inode = os.stat(\u0026#39;file.txt\u0026#39;).st_ino # 获取文件的 inode 编号 # 获取文件的设备 device = os.stat(\u0026#39;file.txt\u0026#39;).st_dev # 获取文件的设备 # 获取文件的硬链接数 nlink = os.stat(\u0026#39;file.txt\u0026#39;).st_nlink # 获取文件的硬链接数 # 获取文件的拥有者 ID uid = os.stat(\u0026#39;file.txt\u0026#39;).st_uid # 获取文件的拥有者 ID # 获取文件的组 ID gid = os.stat(\u0026#39;file.txt\u0026#39;).st_gid # 获取文件的组 ID # 获取文件的大小 size = os.stat(\u0026#39;file.txt\u0026#39;).st_size # 获取文件的大小 # 获取文件的访问时间 atime = os.stat(\u0026#39;file.txt\u0026#39;).st_atime # 获取文件的访问时间 # 获取文件的修改时间 mtime = os.stat(\u0026#39;file.txt\u0026#39;).st_mtime # 获取文件的修改时间 # 获取文件的创建时间 ctime = os.stat(\u0026#39;file.txt\u0026#39;).st_ctime # 获取文件的创建时间 #️⃣ io 模块 # 打开文件 with io.open(\u0026#39;file.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as file: content = file.read() # 读取文件内容 # 创建内存中的文件对象 string_io = io.StringIO() # 创建内存中的字符串文件对象 bytes_io = io.BytesIO() # 创建内存中的字节文件对象 # io.StringIO 方法 string_io.write(\u0026#39;Hello, StringIO!\u0026#39;) # 写入字符串 string_io.seek(0) # 将指针移动到开始位置 content = string_io.read() # 读取字符串 # io.BytesIO 方法 bytes_io.write(b\u0026#39;Hello, BytesIO!\u0026#39;) # 写入字节 bytes_io.seek(0) # 将指针移动到开始位置 byte_content = bytes_io.read() # 读取字节 # 文件读写模式 with io.open(\u0026#39;file.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as file: content = file.read() # 读取文件内容 with io.open(\u0026#39;file.txt\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as file: file.write(\u0026#39;Hello, world!\u0026#39;) # 写入文件内容 # 文件缓冲 buffered_reader = io.BufferedReader(io.BytesIO(b\u0026#39;Hello, BufferedReader!\u0026#39;)) buffered_writer = io.BufferedWriter(io.BytesIO()) buffered_reader.read() # 读取缓冲内容 buffered_writer.write(b\u0026#39;Hello, BufferedWriter!\u0026#39;) # 写入缓冲内容 buffered_writer.flush() # 刷新缓冲区 # 使用 TextIOWrapper 将字节流包装成文本流 bytes_io = io.BytesIO(b\u0026#39;Hello, world!\u0026#39;) text_io = io.TextIOWrapper(bytes_io, encoding=\u0026#39;utf-8\u0026#39;) content = text_io.read() # 读取文本内容 # BufferedIOBase 类方法 buffered_io = io.BufferedIOBase() buffered_io.readable() # 检查是否可读 buffered_io.writable() # 检查是否可写 buffered_io.seekable() # 检查是否可定位 # TextIOBase 类方法 text_io_base = io.TextIOBase() text_io_base.readable() # 检查是否可读 text_io_base.writable() # 检查是否可写 text_io_base.seekable() # 检查是否可定位 # RawIOBase 类方法 raw_io_base = io.RawIOBase() raw_io_base.readable() # 检查是否可读 raw_io_base.writable() # 检查是否可写 raw_io_base.seekable() # 检查是否可定位 # IncrementalNewlineDecoder 类方法 decoder = io.IncrementalNewlineDecoder() decoder.decode(b\u0026#39;line1\\nline2\\n\u0026#39;) # 解码字节 # TextIOWrapper 类方法 text_io = io.TextIOWrapper(io.BytesIO(b\u0026#39;Hello, TextIOWrapper!\u0026#39;), encoding=\u0026#39;utf-8\u0026#39;) text_io.read() # 读取文本内容 text_io.write(\u0026#39;New content\u0026#39;) # 写入文本内容 # StringIO 类方法 string_io = io.StringIO(\u0026#39;Hello, StringIO!\u0026#39;) string_io.read() # 读取字符串 string_io.write(\u0026#39;New content\u0026#39;) # 写入字符串 # BytesIO 类方法 bytes_io = io.BytesIO(b\u0026#39;Hello, BytesIO!\u0026#39;) bytes_io.read() # 读取字节 bytes_io.write(b\u0026#39;New content\u0026#39;) # 写入字节 # IOBase 类方法 io_base = io.IOBase() io_base.readable() # 检查是否可读 io_base.writable() # 检查是否可写 io_base.seekable() # 检查是否可定位 # StringIO 方法 string_io = io.StringIO() string_io.write(\u0026#39;Hello, StringIO!\u0026#39;) string_io.seek(0) # 将指针移动到开始位置 content = string_io.read() # 读取字符串 # BytesIO 方法 bytes_io = io.BytesIO() bytes_io.write(b\u0026#39;Hello, BytesIO!\u0026#39;) bytes_io.seek(0) # 将指针移动到开始位置 byte_content = bytes_io.read() # 读取字节 # FileIO 方法 with io.FileIO(\u0026#39;file.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: content = file.read() # 读取文件内容 # BufferedReader 方法 with io.BufferedReader(io.BytesIO(b\u0026#39;Hello, BufferedReader!\u0026#39;)) as buffered_reader: content = buffered_reader.read() # 读取缓冲内容 # BufferedWriter 方法 with io.BufferedWriter(io.BytesIO()) as buffered_writer: buffered_writer.write(b\u0026#39;Hello, BufferedWriter!\u0026#39;) # 写入缓冲内容 buffered_writer.flush() # 刷新缓冲区 # BufferedRandom 方法 with io.BufferedRandom(io.BytesIO()) as buffered_random: buffered_random.write(b\u0026#39;Hello, BufferedRandom!\u0026#39;) # 写入缓冲内容 buffered_random.seek(0) # 将指针移动到开始位置 content = buffered_random.read() # 读取缓冲内容 # BufferedRWPair 方法 with io.BufferedRWPair(io.BytesIO(), io.BytesIO()) as buffered_rw_pair: buffered_rw_pair.write(b\u0026#39;Hello, BufferedRWPair!\u0026#39;) # 写入缓冲内容 buffered_rw_pair.seek(0) # 将指针移动到开始位置 content = buffered_rw_pair.read() # 读取缓冲内容 # TextIOWrapper 方法 with io.TextIOWrapper(io.BytesIO(b\u0026#39;Hello, TextIOWrapper!\u0026#39;), encoding=\u0026#39;utf-8\u0026#39;) as text_io_wrapper: content = text_io_wrapper.read() # 读取文本内容 # IncrementalNewlineDecoder 方法 decoder = io.IncrementalNewlineDecoder() decoder.decode(b\u0026#39;line1\\nline2\\n\u0026#39;) # 解码字节 # TextIOBase 方法 text_io_base = io.TextIOBase() text_io_base.readable() # 检查是否可读 text_io_base.writable() # 检查是否可写 text_io_base.seekable() # 检查是否可定位 # RawIOBase 方法 raw_io_base = io.RawIOBase() raw_io_base.readable() # 检查是否可读 raw_io_base.writable() # 检查是否可写 raw_io_base.seekable() # 检查是否可定位 # IOBase 方法 io_base = io.IOBase() io_base.readable() # 检查是否可读 io_base.writable() # 检查是否可写 io_base.seekable() # 检查是否可定位 网络编程（socket、urllib） import socket import urllib.request import urllib.parse #️⃣ socket 模块 # 创建 socket 对象 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 创建 TCP socket s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 创建 UDP socket # 连接到服务器 s.connect((\u0026#39;www.example.com\u0026#39;, 80)) # 连接到指定地址和端口 # 绑定到地址和端口 s.bind((\u0026#39;localhost\u0026#39;, 12345)) # 绑定到本地地址和端口 # 监听连接 s.listen(5) # 监听连接（最多 5 个连接） # 接受连接 conn, addr = s.accept() # 接受连接并返回 (连接对象, 地址) # 发送数据 s.send(b\u0026#39;Hello, world!\u0026#39;) # 发送数据（TCP） s.sendto(b\u0026#39;Hello, world!\u0026#39;, (\u0026#39;localhost\u0026#39;, 12345)) # 发送数据（UDP） # 接收数据 data = s.recv(1024) # 接收数据（TCP） data, addr = s.recvfrom(1024) # 接收数据（UDP） # 关闭 socket s.close() # 关闭 socket # 获取主机名和 IP 地址 hostname = socket.gethostname() # 获取主机名 ip_address = socket.gethostbyname(hostname) # 获取 IP 地址 host_info = socket.gethostbyaddr(\u0026#39;8.8.8.8\u0026#39;) # 获取主机信息 # 将主机名和端口转换为二进制格式 binary_addr = socket.gethostbyname_ex(\u0026#39;www.example.com\u0026#39;) # 获取主机信息扩展 binary_addr_info = socket.getaddrinfo(\u0026#39;www.example.com\u0026#39;, 80) # 获取地址信息 # 设置和获取 socket 选项 s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 设置 socket 选项 option_value = s.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR) # 获取 socket 选项 # 设置超时时间 s.settimeout(10.0) # 设置超时时间（秒） timeout = s.gettimeout() # 获取超时时间 # 获取 socket 地址信息 sock_name = s.getsockname() # 获取本地 socket 地址 peer_name = s.getpeername() # 获取远程 socket 地址 # 关闭 socket 的读和写 s.shutdown(socket.SHUT_RDWR) # 关闭 socket 的读和写 # 创建和处理非阻塞 socket s.setblocking(0) # 设置非阻塞模式 s.setblocking(1) # 设置阻塞模式 # 创建和处理文件描述符 fd = s.fileno() # 获取文件描述符 s = socket.socket(fileno=fd) # 从文件描述符创建 socket # 使用上下文管理器管理 socket with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((\u0026#39;www.example.com\u0026#39;, 80)) s.sendall(b\u0026#39;GET / HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n\u0026#39;) response = s.recv(4096) print(response) # 创建和处理 Unix 域 socket s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) # 创建 Unix 域 socket s.bind(\u0026#39;/tmp/socket_file\u0026#39;) # 绑定到文件路径 s.connect(\u0026#39;/tmp/socket_file\u0026#39;) # 连接到文件路径 # 使用 SSL 包装 socket import ssl wrapped_socket = ssl.wrap_socket(s, ssl_version=ssl.PROTOCOL_TLS) # 使用 SSL 包装 socket # 使用 select 模块多路复用 import select readable, writable, exceptional = select.select([s], [s], [s], timeout) # 多路复用 # 获取网络接口名称和地址 interface_name = socket.if_nameindex() # 获取网络接口名称 interface_addr = socket.if_nametoindex(\u0026#39;eth0\u0026#39;) # 获取网络接口地址 # 使用 getaddrinfo 获取更多详细信息 addr_info = socket.getaddrinfo(\u0026#39;www.example.com\u0026#39;, None) # 获取地址信息 # 设置 TCP_NODELAY 选项以禁用 Nagle 算法 s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1) # 设置 TCP_NODELAY 选项 # 使用 socketpair 创建一对连接的套接字 parent_sock, child_sock = socket.socketpair() # 创建一对连接的套接字 #️⃣ urllib 模块 # 使用 urlopen 打开 URL response = urllib.request.urlopen(\u0026#39;http://www.example.com\u0026#39;) # 打开 URL html = response.read() # 读取响应内容 # 使用 Request 自定义请求 req = urllib.request.Request(\u0026#39;http://www.example.com\u0026#39;) req.add_header(\u0026#39;User-Agent\u0026#39;, \u0026#39;Mozilla/5.0\u0026#39;) response = urllib.request.urlopen(req) html = response.read() # 使用 urlretrieve 下载文件 filename, headers = urllib.request.urlretrieve(\u0026#39;http://www.example.com/file.zip\u0026#39;, \u0026#39;file.zip\u0026#39;) # 下载文件 # 使用 urlcleanup 清理临时文件 urllib.request.urlcleanup() # 清理临时文件 # 编码和解码 URL 参数 params = {\u0026#39;param1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;param2\u0026#39;: \u0026#39;value2\u0026#39;} query_string = urllib.parse.urlencode(params) # 编码 URL 参数 parsed_params = urllib.parse.parse_qs(query_string) # 解码 URL 参数 # 解析 URL parsed_url = urllib.parse.urlparse(\u0026#39;http://www.example.com/path?query=arg\u0026#39;) # 解析 URL scheme = parsed_url.scheme # 获取 URL 的 scheme netloc = parsed_url.netloc # 获取 URL 的 netloc path = parsed_url.path # 获取 URL 的 path query = parsed_url.query # 获取 URL 的 query # 构建 URL url = urllib.parse.urlunparse((\u0026#39;http\u0026#39;, \u0026#39;www.example.com\u0026#39;, \u0026#39;/path\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;query=arg\u0026#39;, \u0026#39;\u0026#39;)) # 构建 URL # 使用 urlencode 编码查询参数 params = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} encoded_params = urllib.parse.urlencode(params) # 编码查询参数 # 将查询参数添加到 URL url = \u0026#39;http://www.example.com\u0026#39; full_url = url + \u0026#39;?\u0026#39; + encoded_params # 将查询参数添加到 URL # 解析查询参数 query_params = urllib.parse.parse_qs(\u0026#39;key1=value1\u0026amp;key2=value2\u0026#39;) # 解析查询参数 # 解析 URL 并返回命名元组 parsed_url = urllib.parse.urlsplit(\u0026#39;http://www.example.com/path?query=arg\u0026#39;) # 解析 URL 并返回命名元组 # 解析和构建 URL 编码的数据 parsed_data = urllib.parse.parse_qsl(\u0026#39;key1=value1\u0026amp;key2=value2\u0026#39;) # 解析 URL 编码的数据 # 编码和解码 URL 组件 quoted_url = urllib.parse.quote(\u0026#39;http://www.example.com/dir/file name\u0026#39;) # 编码 URL 组件 unquoted_url = urllib.parse.unquote(\u0026#39;http%3A%2F%2Fwww.example.com%2Fdir%2Ffile%20name\u0026#39;) # 解码 URL 组件 # 编码和解码字节数据 quoted_bytes = urllib.parse.quote_plus(b\u0026#39;key1=value1\u0026amp;key2=value2\u0026#39;) # 编码字节数据 unquoted_bytes = urllib.parse.unquote_plus(\u0026#39;key1%3Dvalue1%26key2%3Dvalue2\u0026#39;) # 解码字节数据 # URL 编码数据 data = {\u0026#39;param1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;param2\u0026#39;: \u0026#39;value2\u0026#39;} encoded_data = urllib.parse.urlencode(data).encode(\u0026#39;utf-8\u0026#39;) # URL 编码数据 # 使用 opener 自定义请求处理 opener = urllib.request.build_opener() opener.addheaders = [(\u0026#39;User-Agent\u0026#39;, \u0026#39;Mozilla/5.0\u0026#39;)] response = opener.open(\u0026#39;http://www.example.com\u0026#39;) html = response.read() # 安装 opener 作为默认打开器 urllib.request.install_opener(opener) # 安装 opener # 处理 HTTP 基本认证 auth_handler = urllib.request.HTTPBasicAuthHandler() auth_handler.add_password(realm=\u0026#39;realm\u0026#39;, uri=\u0026#39;http://www.example.com\u0026#39;, user=\u0026#39;username\u0026#39;, passwd=\u0026#39;password\u0026#39;) opener = urllib.request.build_opener(auth_handler) response = opener.open(\u0026#39;http://www.example.com\u0026#39;) html = response.read() # 处理 HTTP 代理 proxy_handler = urllib.request.ProxyHandler({\u0026#39;http\u0026#39;: \u0026#39;http://proxy.example.com:8080\u0026#39;}) opener = urllib.request.build_opener(proxy_handler) response = opener.open(\u0026#39;http://www.example.com\u0026#39;) html = response.read() # 处理 HTTP cookies import http.cookiejar cookie_jar = http.cookiejar.CookieJar() cookie_handler = urllib.request.HTTPCookieProcessor(cookie_jar) opener = urllib.request.build_opener(cookie_handler) response = opener.open(\u0026#39;http://www.example.com\u0026#39;) html = response.read() # 自定义 HTTP 方法 class CustomMethod(urllib.request.Request): def get_method(self): return \u0026#39;PUT\u0026#39; req = CustomMethod(\u0026#39;http://www.example.com\u0026#39;, data=b\u0026#39;Updated data\u0026#39;) response = urllib.request.urlopen(req) html = response.read() # 使用 context 管理 SSL 设置 import ssl context = ssl.create_default_context() context.check_hostname = False context.verify_mode = ssl.CERT_NONE response = urllib.request.urlopen(\u0026#39;https://www.example.com\u0026#39;, context=context) html = response.read() 日期和时间处理（datetime、time） import datetime import time #️⃣ datetime 模块 # 获取当前日期和时间 now = datetime.datetime.now() # 获取当前日期和时间 today = datetime.date.today() # 获取当前日期 # 创建日期对象 date = datetime.date(2023, 5, 31) # 创建日期对象 time = datetime.time(12, 34, 56) # 创建时间对象 datetime_obj = datetime.datetime(2023, 5, 31, 12, 34, 56) # 创建日期时间对象 # 格式化日期和时间 formatted_date = date.strftime(\u0026#39;%Y-%m-%d\u0026#39;) # 格式化日期 formatted_time = time.strftime(\u0026#39;%H:%M:%S\u0026#39;) # 格式化时间 formatted_datetime = datetime_obj.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) # 格式化日期时间 # 解析日期和时间 parsed_date = datetime.datetime.strptime(\u0026#39;2023-05-31\u0026#39;, \u0026#39;%Y-%m-%d\u0026#39;).date() # 解析日期 parsed_time = datetime.datetime.strptime(\u0026#39;12:34:56\u0026#39;, \u0026#39;%H:%M:%S\u0026#39;).time() # 解析时间 parsed_datetime = datetime.datetime.strptime(\u0026#39;2023-05-31 12:34:56\u0026#39;, \u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) # 解析日期时间 # 获取日期和时间的组件 year = date.year # 获取年 month = date.month # 获取月 day = date.day # 获取日 hour = time.hour # 获取小时 minute = time.minute # 获取分钟 second = time.second # 获取秒 # 计算时间差 delta = datetime.timedelta(days=5) # 创建时间差对象 new_date = date + delta # 日期加时间差 new_datetime = datetime_obj - delta # 日期时间减时间差 # 比较日期和时间 is_equal = date == datetime.date(2023, 5, 31) # 比较日期是否相等 is_before = datetime_obj \u0026lt; datetime.datetime(2024, 1, 1) # 比较日期时间是否在之前 is_after = time \u0026gt; datetime.time(12, 0, 0) # 比较时间是否在之后 # 获取日期和时间的最大值和最小值 min_date = datetime.date.min # 获取日期的最小值 max_date = datetime.date.max # 获取日期的最大值 min_time = datetime.time.min # 获取时间的最小值 max_time = datetime.time.max # 获取时间的最大值 min_datetime = datetime.datetime.min # 获取日期时间的最小值 max_datetime = datetime.datetime.max # 获取日期时间的最大值 # 获取当前时间的 UTC 时间和本地时间 utc_now = datetime.datetime.utcnow() # 获取当前 UTC 时间 local_now = datetime.datetime.now() # 获取当前本地时间 # 将本地时间转换为 UTC 时间 local_datetime = datetime.datetime(2023, 5, 31, 12, 34, 56) utc_datetime = local_datetime.astimezone(datetime.timezone.utc) # 将本地时间转换为 UTC 时间 # 将 UTC 时间转换为本地时间 utc_datetime = datetime.datetime(2023, 5, 31, 12, 34, 56, tzinfo=datetime.timezone.utc) local_datetime = utc_datetime.astimezone() # 将 UTC 时间转换为本地时间 # 获取时区信息 timezone = datetime.timezone(datetime.timedelta(hours=8)) # 创建时区对象 utc_offset = timezone.utcoffset(datetime_obj) # 获取时区偏移 # 使用自定义时区信息 class CustomTZ(datetime.tzinfo): def utcoffset(self, dt): return datetime.timedelta(hours=8) def dst(self, dt): return datetime.timedelta(0) custom_tz = CustomTZ() datetime_with_tz = datetime.datetime(2023, 5, 31, 12, 34, 56, tzinfo=custom_tz) # 创建带时区的日期时间对象 # 使用相对时间 relativedelta = datetime.timedelta(days=1, months=1) # 创建相对时间对象 new_datetime = datetime_obj + relativedelta # 日期时间加相对时间 # 使用 ISO 8601 格式 iso_format = datetime_obj.isoformat() # 获取 ISO 8601 格式的日期时间字符串 parsed_iso_datetime = datetime.datetime.fromisoformat(\u0026#39;2023-05-31T12:34:56\u0026#39;) # 解析 ISO 8601 格式的日期时间字符串 # 获取一周的开始日期和结束日期 start_of_week = date - datetime.timedelta(days=date.weekday()) # 获取一周的开始日期 end_of_week = start_of_week + datetime.timedelta(days=6) # 获取一周的结束日期 #️⃣ time 模块 # 获取当前时间戳 timestamp = time.time() # 获取当前时间戳 # 将时间戳转换为本地时间 local_time = time.localtime(timestamp) # 将时间戳转换为本地时间 formatted_local_time = time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;, local_time) # 格式化本地时间 # 将时间戳转换为 UTC 时间 utc_time = time.gmtime(timestamp) # 将时间戳转换为 UTC 时间 formatted_utc_time = time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;, utc_time) # 格式化 UTC 时间 # 解析时间字符串 parsed_time = time.strptime(\u0026#39;2023-05-31 12:34:56\u0026#39;, \u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) # 解析时间字符串 # 获取当前时间的时间戳 current_timestamp = time.mktime(local_time) # 获取当前时间的时间戳 # 暂停执行 time.sleep(1) # 暂停执行 1 秒 # 获取处理器时间 processor_time = time.process_time() # 获取处理器时间 # 获取时间戳的小数部分 timestamp_fraction = time.time() % 1 # 获取时间戳的小数部分 # 获取当前时间 current_time = time.ctime() # 获取当前时间的字符串表示 current_localtime = time.localtime() # 获取当前时间的本地时间 current_gmtime = time.gmtime() # 获取当前时间的 UTC 时间 # 格式化时间 formatted_time = time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;, current_localtime) # 格式化本地时间 formatted_utc_time = time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;, current_gmtime) # 格式化 UTC 时间 # 获取时间组件 year = local_time.tm_year # 获取年 month = local_time.tm_mon # 获取月 day = local_time.tm_mday # 获取日 hour = local_time.tm_hour # 获取小时 minute = local_time.tm_min # 获取分钟 second = local_time.tm_sec # 获取秒 # 使用 perf_counter 进行精确计时 start = time.perf_counter() # 获取开始时间 # 执行一些操作 end = time.perf_counter() # 获取结束时间 elapsed = end - start # 计算经过的时间 # 使用 monotonic 进行单调计时 start = time.monotonic() # 获取开始时间 # 执行一些操作 end = time.monotonic() # 获取结束时间 elapsed = end - start # 计算经过的时间 # 使用 thread_time 进行线程计时 start = time.thread_time() # 获取开始时间 # 执行一些操作 end = time.thread_time() # 获取结束时间 elapsed = end - start # 计算经过的时间 # 使用 time_ns 获取纳秒级时间戳 nanoseconds = time.time_ns() # 获取纳秒级时间戳 数学运算（math、random） import math import random #️⃣ math 模块 # 数学常数 pi = math.pi # 圆周率 e = math.e # 自然常数 tau = math.tau # 圆周率的两倍 inf = math.inf # 正无穷大 nan = math.nan # 不是一个数字 # 四舍五入 result = math.ceil(4.2) # 返回不小于 x 的最小整数 result = math.floor(4.8) # 返回不大于 x 的最大整数 result = math.trunc(4.8) # 返回 x 的整数部分（截断） result = round(4.6) # 返回四舍五入后的值 # 幂和对数 result = math.exp(1) # 返回 e 的 x 次幂 result = math.log(2.718) # 返回 x 的自然对数 result = math.log(100, 10) # 返回 x 以 base 为底的对数 result = math.log2(8) # 返回 x 以 2 为底的对数 result = math.log10(100) # 返回 x 以 10 为底的对数 result = math.pow(2, 3) # 返回 x 的 y 次幂 result = math.sqrt(25) # 返回 x 的平方根 # 三角函数 result = math.sin(math.pi / 2) # 返回 x 的正弦 result = math.cos(math.pi) # 返回 x 的余弦 result = math.tan(math.pi / 4) # 返回 x 的正切 result = math.asin(1) # 返回 x 的反正弦 result = math.acos(1) # 返回 x 的反余弦 result = math.atan(1) # 返回 x 的反正切 result = math.atan2(1, 1) # 返回 y/x 的反正切 # 双曲函数 result = math.sinh(1) # 返回 x 的双曲正弦 result = math.cosh(1) # 返回 x 的双曲余弦 result = math.tanh(1) # 返回 x 的双曲正切 result = math.asinh(1) # 返回 x 的反双曲正弦 result = math.acosh(1) # 返回 x 的反双曲余弦 result = math.atanh(0.5) # 返回 x 的反双曲正切 # 角度转换 result = math.degrees(math.pi) # 将弧度转换为角度 result = math.radians(180) # 将角度转换为弧度 # 特殊函数 result = math.factorial(5) # 返回 x 的阶乘 result = math.gamma(5) # 返回 x 的伽玛函数值 result = math.lgamma(5) # 返回 x 的伽玛函数的自然对数值 # 浮点数运算 result = math.fabs(-5) # 返回 x 的绝对值 result = math.fmod(7, 3) # 返回 x % y 的浮点数余数 result = math.frexp(8) # 返回 (m, e) 使得 x = m * 2**e result = math.ldexp(0.5, 3) # 返回 x * (2**i) result = math.modf(4.5) # 返回 x 的整数部分和小数部分 result = math.copysign(1, -2) # 返回 y 的符号加上 x 的绝对值 result = math.isfinite(4.5) # 判断 x 是否是有限数 result = math.isinf(math.inf) # 判断 x 是否是无穷大 result = math.isnan(math.nan) # 判断 x 是否是 NaN result = math.isclose(1.0001, 1.0002, rel_tol=1e-5) # 判断两个数是否接近 # 其他函数 result = math.gcd(48, 180) # 返回 x 和 y 的最大公约数 result = math.lcm(48, 180) # 返回 x 和 y 的最小公倍数 result = math.prod([1, 2, 3, 4]) # 返回可迭代对象中所有元素的乘积 result = math.dist([1, 2], [4, 6]) # 返回两个点之间的欧几里得距离 result = math.hypot(3, 4) # 返回欧几里得范数 sqrt(x*x + y*y) #️⃣ random 模块 # 初始化随机数生成器 random.seed(42) # 设置随机数生成器的种子 random.seed() # 使用当前系统时间初始化随机数生成器 # 生成随机数 result = random.random() # 生成一个 0 到 1 之间的随机浮点数 result = random.uniform(1, 10) # 生成一个 a 到 b 之间的随机浮点数 result = random.randint(1, 10) # 生成一个 a 到 b 之间的随机整数，包括 a 和 b result = random.randrange(1, 10) # 生成一个 a 到 b 之间的随机整数，不包括 b result = random.choice([1, 2, 3, 4, 5]) # 从序列中随机选择一个元素 result = random.choices([1, 2, 3, 4, 5], k=3) # 从序列中随机选择 k 个元素，允许重复 result = random.sample([1, 2, 3, 4, 5], k=3) # 从序列中随机选择 k 个元素，不允许重复 result = random.betavariate(2, 5) # Beta 分布 result = random.expovariate(1 / 5) # 指数分布 result = random.gammavariate(1, 2) # Gamma 分布 result = random.gauss(0, 1) # 正态（高斯）分布 result = random.lognormvariate(0, 1) # 对数正态分布 result = random.normalvariate(0, 1) # 正态分布 result = random.vonmisesvariate(0, 1) # 冯·米塞斯分布 result = random.paretovariate(1) # 帕累托分布 result = random.weibullvariate(1, 1) # 韦布尔分布 # 随机打乱序列 my_list = [1, 2, 3, 4, 5] random.shuffle(my_list) # 随机打乱序列 字符串处理（re、string） import re import string #️⃣ re 模块 # 匹配和搜索 pattern = r\u0026#39;\\d+\u0026#39; # 匹配一个或多个数字 text = \u0026#39;My number is 12345\u0026#39; match = re.match(pattern, text) # 从字符串开始处匹配 if match: print(match.group()) # 输出匹配的字符串 search = re.search(pattern, text) # 搜索整个字符串 if search: print(search.group()) # 输出匹配的字符串 findall = re.findall(pattern, text) # 查找所有匹配 print(findall) # 输出所有匹配的列表 finditer = re.finditer(pattern, text) # 返回一个迭代器，产生所有匹配 for match in finditer: print(match.group()) # 输出匹配的字符串 # 替换和分割 sub = re.sub(r\u0026#39;\\d+\u0026#39;, \u0026#39;#\u0026#39;, text) # 替换所有匹配的子串 print(sub) # 输出替换后的字符串 subn = re.subn(r\u0026#39;\\d+\u0026#39;, \u0026#39;#\u0026#39;, text) # 替换所有匹配的子串并返回替换次数 print(subn) # 输出替换后的字符串和替换次数 split = re.split(r\u0026#39;\\s+\u0026#39;, text) # 根据匹配分割字符串 print(split) # 输出分割后的列表 # 编译正则表达式 compiled_pattern = re.compile(pattern) # 编译正则表达式 match = compiled_pattern.match(text) # 使用编译的正则表达式匹配 search = compiled_pattern.search(text) # 使用编译的正则表达式搜索 findall = compiled_pattern.findall(text) # 使用编译的正则表达式查找所有匹配 finditer = compiled_pattern.finditer(text) # 使用编译的正则表达式返回一个迭代器 # 分组 pattern = r\u0026#39;(\\d+)-(\\d+)-(\\d+)\u0026#39; text = \u0026#39;My number is 123-456-7890\u0026#39; match = re.search(pattern, text) # 搜索整个字符串 if match: print(match.group(0)) # 输出整个匹配 print(match.group(1)) # 输出第一个分组 print(match.group(2)) # 输出第二个分组 print(match.group(3)) # 输出第三个分组 # 使用命名分组 pattern = r\u0026#39;(?P\u0026lt;area\u0026gt;\\d+)-(?P\u0026lt;exchange\u0026gt;\\d+)-(?P\u0026lt;number\u0026gt;\\d+)\u0026#39; match = re.search(pattern, text) if match: print(match.group(\u0026#39;area\u0026#39;)) # 输出命名分组 \u0026#39;area\u0026#39; print(match.group(\u0026#39;exchange\u0026#39;)) # 输出命名分组 \u0026#39;exchange\u0026#39; print(match.group(\u0026#39;number\u0026#39;)) # 输出命名分组 \u0026#39;number\u0026#39; # 正则表达式标志 pattern = r\u0026#39;hello world\u0026#39; text = \u0026#39;Hello World\u0026#39; match = re.search(pattern, text, re.IGNORECASE) # 忽略大小写匹配 if match: print(match.group()) # 分割和替换中使用捕获组 pattern = r\u0026#39;(\\d+)\u0026#39; text = \u0026#39;123abc456\u0026#39; split = re.split(pattern, text) # 使用捕获组进行分割 print(split) # 输出分割后的列表 sub = re.sub(pattern, r\u0026#39;(\\1)\u0026#39;, text) # 使用捕获组进行替换 print(sub) # 输出替换后的字符串 #️⃣ string 模块 # 常量 print(string.ascii_letters) # 所有 ASCII 字母（大写和小写） print(string.ascii_lowercase) # 所有小写 ASCII 字母 print(string.ascii_uppercase) # 所有大写 ASCII 字母 print(string.digits) # 所有数字字符 print(string.hexdigits) # 所有十六进制字符 print(string.octdigits) # 所有八进制字符 print(string.punctuation) # 所有标点符号 print(string.printable) # 所有可打印字符 print(string.whitespace) # 所有空白字符 # 字符串模板 template = string.Template(\u0026#39;Hello, $name!\u0026#39;) result = template.substitute(name=\u0026#39;World\u0026#39;) # 使用字典或关键字参数替换模板中的变量 print(result) # 输出 \u0026#39;Hello, World!\u0026#39; safe_result = template.safe_substitute(name=\u0026#39;World\u0026#39;) # 与 substitute 类似，但未定义的变量不会引发 KeyError print(safe_result) # 输出 \u0026#39;Hello, World!\u0026#39; # 自定义字符串格式化 custom_formatter = string.Formatter() formatted_string = custom_formatter.format(\u0026#39;Hello, {}!\u0026#39;, \u0026#39;World\u0026#39;) # 使用自定义格式化器格式化字符串 print(formatted_string) # 输出 \u0026#39;Hello, World!\u0026#39; # 使用 string 模块的一些方法 result = string.capwords(\u0026#39;hello world\u0026#39;) # 将字符串中的每个单词首字母大写 print(result) # 输出 \u0026#39;Hello World\u0026#39; 数据结构（list、tuple、dict、set） #️⃣ list 列表 # 创建列表 my_list = [1, 2, 3, 4, 5] # 添加元素 my_list.append(6) # 在列表末尾添加元素 my_list.insert(0, 0) # 在指定位置插入元素 # 删除元素 my_list.pop() # 删除并返回列表末尾的元素 my_list.remove(3) # 删除指定值的第一个元素 del my_list[0] # 删除指定位置的元素 # 访问元素 print(my_list[0]) # 访问指定位置的元素 print(my_list[-1]) # 访问列表末尾的元素 # 修改元素 my_list[0] = 10 # 修改指定位置的元素 # 列表切片 print(my_list[1:3]) # 获取指定范围的子列表 # 查找元素 print(3 in my_list) # 判断元素是否在列表中 # 获取列表长度 print(len(my_list)) # 获取列表的长度 # 排序 my_list.sort() # 对列表进行排序（就地排序） sorted_list = sorted(my_list) # 返回排序后的新列表 # 反转 my_list.reverse() # 反转列表 # 清空列表 my_list.clear() # 清空列表 # 复制列表 new_list = my_list.copy() # 复制列表（浅拷贝） # 列表推导式 squared = [x ** 2 for x in range(5)] # 使用列表推导式生成新列表 #️⃣ tuple 元组 # 创建元组 my_tuple = (1, 2, 3, 4, 5) # 访问元素 print(my_tuple[0]) # 访问指定位置的元素 print(my_tuple[-1]) # 访问元组末尾的元素 # 元组切片 print(my_tuple[1:3]) # 获取指定范围的子元组 # 查找元素 print(3 in my_tuple) # 判断元素是否在元组中 # 获取元组长度 print(len(my_tuple)) # 获取元组的长度 # 元组拆包 a, b, c = my_tuple # 元组拆包 # 不可变性 # my_tuple[0] = 10 # 尝试修改元组中的元素会引发 TypeError #️⃣ dict 字典 # 创建字典 my_dict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} # 添加或修改元素 my_dict[\u0026#39;d\u0026#39;] = 4 # 添加新键值对 my_dict[\u0026#39;a\u0026#39;] = 10 # 修改指定键的值 # 删除元素 my_dict.pop(\u0026#39;b\u0026#39;) # 删除指定键的键值对 del my_dict[\u0026#39;c\u0026#39;] # 删除指定键的键值对 # 访问元素 print(my_dict[\u0026#39;a\u0026#39;]) # 访问指定键的值 # 获取所有键或值 keys = my_dict.keys() # 获取所有键 values = my_dict.values() # 获取所有值 items = my_dict.items() # 获取所有键值对 # 查找元素 print(\u0026#39;b\u0026#39; in my_dict) # 判断键是否在字典中 # 获取字典长度 print(len(my_dict)) # 获取字典的长度 # 清空字典 my_dict.clear() # 清空字典 # 复制字典 new_dict = my_dict.copy() # 复制字典（浅拷贝） #️⃣ set 集合 # 创建集合 my_set = {1, 2, 3, 4, 5} # 添加元素 my_set.add(6) # 添加元素 my_set.update([7, 8, 9]) # 添加多个元素 # 删除元素 my_set.remove(3) # 删除指定元素 my_set.discard(10) # 删除指定元素（如果存在） # 查找元素 print(3 in my_set) # 判断元素是否在集合中 # 获取集合长度 print(len(my_set)) # 获取集合的长度 # 清空集合 my_set.clear() # 清空集合 # 复制集合 new_set = my_set.copy() # 复制集合（浅拷贝） # 集合运算 set1 = {1, 2, 3} set2 = {3, 4, 5} union_set = set1 | set2 # 并集 intersection_set = set1 \u0026amp; set2 # 交集 difference_set = set1 - set2 # 差集 symmetric_difference_set = set1 ^ set2 # 对称差集 对象编程（class、object） #️⃣ 定义类和创建对象 class MyClass: \u0026#34;\u0026#34;\u0026#34;一个简单的类示例\u0026#34;\u0026#34;\u0026#34; # 类属性 class_attr = \u0026#39;class_attribute\u0026#39; def __init__(self, arg1, arg2): \u0026#34;\u0026#34;\u0026#34;构造方法\u0026#34;\u0026#34;\u0026#34; self.instance_attr1 = arg1 # 实例属性1 self.instance_attr2 = arg2 # 实例属性2 def instance_method(self): \u0026#34;\u0026#34;\u0026#34;实例方法\u0026#34;\u0026#34;\u0026#34; return self.instance_attr1 + self.instance_attr2 @classmethod def class_method(cls): \u0026#34;\u0026#34;\u0026#34;类方法\u0026#34;\u0026#34;\u0026#34; return cls.class_attr @staticmethod def static_method(): \u0026#34;\u0026#34;\u0026#34;静态方法\u0026#34;\u0026#34;\u0026#34; return \u0026#39;static_method\u0026#39; # 创建对象 obj1 = MyClass(10, 20) obj2 = MyClass(30, 40) # 访问属性和调用方法 print(obj1.instance_attr1) # 访问实例属性 print(obj2.instance_method()) # 调用实例方法 # 访问类属性和调用类方法 print(MyClass.class_attr) # 访问类属性 print(MyClass.class_method()) # 调用类方法 # 调用静态方法 print(MyClass.static_method()) # 调用静态方法 #️⃣ 继承和多态 class Parent: \u0026#34;\u0026#34;\u0026#34;父类\u0026#34;\u0026#34;\u0026#34; def speak(self): \u0026#34;\u0026#34;\u0026#34;父类的方法\u0026#34;\u0026#34;\u0026#34; return \u0026#34;Parent speaks\u0026#34; class Child(Parent): \u0026#34;\u0026#34;\u0026#34;子类\u0026#34;\u0026#34;\u0026#34; def speak(self): \u0026#34;\u0026#34;\u0026#34;子类重写了父类的方法\u0026#34;\u0026#34;\u0026#34; return \u0026#34;Child speaks\u0026#34; # 创建对象 parent_obj = Parent() child_obj = Child() # 调用方法 print(parent_obj.speak()) # 调用父类的方法 print(child_obj.speak()) # 调用子类的方法 # 多重继承 class A: \u0026#34;\u0026#34;\u0026#34;类A\u0026#34;\u0026#34;\u0026#34; def speak(self): return \u0026#34;A speaks\u0026#34; class B: \u0026#34;\u0026#34;\u0026#34;类B\u0026#34;\u0026#34;\u0026#34; def speak(self): return \u0026#34;B speaks\u0026#34; class C(A, B): \u0026#34;\u0026#34;\u0026#34;类C\u0026#34;\u0026#34;\u0026#34; pass # 创建对象 c_obj = C() # 调用方法 print(c_obj.speak()) # 输出 \u0026#34;A speaks\u0026#34;，按照继承顺序调用方法 #️⃣ 魔术方法（特殊方法） class MagicClass: \u0026#34;\u0026#34;\u0026#34;魔术方法示例类\u0026#34;\u0026#34;\u0026#34; def __init__(self, value): \u0026#34;\u0026#34;\u0026#34;初始化方法\u0026#34;\u0026#34;\u0026#34; self.value = value def __repr__(self): \u0026#34;\u0026#34;\u0026#34;repr 方法\u0026#34;\u0026#34;\u0026#34; return f\u0026#39;MagicClass({self.value})\u0026#39; def __str__(self): \u0026#34;\u0026#34;\u0026#34;str 方法\u0026#34;\u0026#34;\u0026#34; return f\u0026#39;A MagicClass instance with value {self.value}\u0026#39; # 创建对象 magic_obj = MagicClass(42) # 调用特殊方法 print(repr(magic_obj)) # 调用 __repr__ 方法 print(str(magic_obj)) # 调用 __str__ 方法 "},{"id":10,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E5%85%B3%E4%BA%8E%E7%AF%AE%E7%90%83/","title":"关于篮球","section":"个人","content":"健壮的身体和娴熟的技术\n关于投篮 动作要点: 调整脚步,左脚在前,右脚在后 想象下面有个凳子坐下去,接着像弹簧一样起来 辅助手确定最左出手范围，控制方向 直臂出手,打直手腕 手指拨球,压腕让球保持高度和旋速 保持投篮动作 目标是弧度尽量高，发力尽量轻松 要往上发力投篮，就要往下下面压，下半身和上半身要发力不脱节 投篮手不要抓球，食指和中指张开，压腕时合拢 辅助手确定投篮范围，控制方向 在脚发力完成之前， 投篮夹角＜90度 投篮弧度要是一个抛物线，高度要高于篮板上沿 几个重要的指标：球旋速、球高度 关于上篮 果冻上篮，手心正对着篮板，旋球到篮板的左上角或者右上角 多观察全局位置 攻击前侧脚 关于运球 减少运球时间 只突破不经常终结，多多分球 踮脚尖走路能锻炼小腿肌肉和踝关节稳定性。 一直收肚子能减少身体负担 "},{"id":11,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E5%85%B3%E4%BA%8E%E6%88%91/","title":"关于我","section":"个人","content":" 个人介绍 23 岁, 1年工作经验,软工专业, 一名软件开发者。\n热爱互联网行业, 擅长做后端开发, 略懂一点对话AI。\n爱做项目, 编程 5 年间, 有 15+ 独立项目开发经验 。\n喜欢记录总结, www.ltao.top 博客目前已运行近 1 年\n个人经历 大学期间, 我自学了多种编程语言和技术栈, 包括Python 后端、前端、大数据等，大三曾取得金砖大赛国二奖,\n大四毕业取得湖南省程序设计二等奖和省优秀毕业生,并以基于用户行为的新能源充电桩项目入选校企合作名单。\n毕业后, 实习顺利入职湖南超能机器人做 AI 对话, 作为项目核心开发者,将该 AI 对话项目由零迭代到上线。\n目前就职深圳亿达信息， 担任 Python 工程师, 负责公司后端接口开发与测试。\n工作经历 2021年11月-2023年3月 湖南超能机器人 AI助理 智能问诊项目 负责人 清洗训练数据近 2w 条, 处理NLU 和 NLG 部分工作, 并对接后端开始内部测试 从零推动 AI 对话项目版本迭代到上线开售 2023年4月-至今 深圳亿达信息 Python开发 支付分账项目 参与者 迭代项目版本 测试 技术栈 熟悉Python的Django,Flask等后端框架，掌握基本的数据结构和常见算法 熟悉Linux系统应用部署以及管理，能独立部署项目到服务器 联系我 邮箱: liao4256@qq.com\n所在地: 深圳\n"},{"id":12,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"计算机网络","section":"理论知识","content":" 概览图 网络层 _ 设计思路 简单灵活的,无连接的,尽最大努力交付的数据报服务 IP\\nInternet Protocol\\n网际协议 [#FFBBCC] 配套协议 ARP\\nAddress Resolution Protocol\\n地址解析协议(IP-\u0026gt;MAC) ICMP\\nInternet Control Message Protocol\\n控制报文协议 IGMP\\nInternet Group Management Protocol\\n网际租管理协议 [#FFBBCC] IP 地址编址 历史发展阶段, 分类的IP地址\u0026gt;\u0026gt;子网的划分\u0026gt;\u0026gt;构成超网 构成 {\u0026lt;网络号\u0026gt;,\u0026lt;主机号\u0026gt;} 分类 A 类,{ \u0026lt;网络号(开头为0),8位\u0026gt;,\u0026lt;主机号,24位\u0026gt;} B 类,{ \u0026lt;网络号(开头为10),16位\u0026gt;,\u0026lt;主机号,16位\u0026gt;} C 类,{ \u0026lt;网络号(开头为110),24位\u0026gt;,\u0026lt;主机号,8位\u0026gt;} D 类,开头为1110,多播地址 E 类,保留为今后使用 ARP\\nAddress Resolution Protocol\\n地址解析协议 功能:用IP地址找到局域网内的对应硬件地址 关键词:ARP cache, 广播, 局域网 过程:广播问局域网内主机对应IP的MAC地址,\\n匹配主机单播回应 应用层 应用层协议是为了各应用进程需要不同的通信规则而存在的, 也是要依赖运输层所提供的基本通信服务。\n概念 应用层主要包括以下内容\n域名系统 DNS WWW 和 HTTP 协议 电子邮件的相关协议，SMTP 协议和 POP3 协议、IMAP 协议 域名系统 DNS DNS 的作用是将域名转为IP地址，具体的过程是应用进程调用 resolver（解析程序），发送包含待解析的域名的 DNS 请求报文，通过 UDP 进行再包装发送到本地域名服务器，本地域名服务器搜索以后，把对应的 IP 地址放在回答报文返回。\n域名 域名是一个空间概念，可比作一个盒子，最大的一个盒就是顶级域名，再里面的盒子叫做二级域名，再里面的盒子叫做三级域名。\n如www.baidu.com这个域名，从左到右域名等级依次提高，com就是顶级域名，baidu则是二级域名，www是三级域名。\n这些顶级域名和二级域名以及其他等级的域名都是要遵守域名规则\n必须是英文字母或数字，不区分大小写 一个域名长度不超过 63 个字符 所有域名加起来长度 255 个字符 运输层 TCP 协议 特点:面向连接(虚连接);点对点;可靠有序,不丢不重;全双工通信;字节流\n全双工通信:发送缓存和接收缓存\nTCP首部 0 8 16 24 31 --------------------------------------------------------------------------- 源端口 | 目的端口 --------------------------------------------------------------------------- 序号(seq) --------------------------------------------------------------------------- 确认号 --------------------------------------------------------------------------- 首部长度|保留|[URG,ACK,PSH,RST,SYN,FIN] |\t接收窗口大小 --------------------------------------------------------------------------- 检验和 | 紧急指针 --------------------------------------------------------------------------- 选项(长度可变) | 填充 --------------------------------------------------------------------------- 图 TCP的报文段首部 说明:\nTCP首部总长为21B(20B固定,1B占位),第一行总长度都是4B(32位), |表示所占区分割线,如源端口所占为[0,16]的区域 序号(seq):在TCP连接的字节流中,报文段中第一个字节的序号\n确认号: 下一个要收报文段的序号, 序号为N, 则序号到N-1的数据都已收到\n首部长度:表示TCP首部的长度,单位为4B\nURG:紧急位,调整报文段优先级\nACK: TCP连接之后,ACk=1,标识为有效报文\nPSH: 不需要等发送缓存填满才发\nSYN: 标识为同步报文\nFIN: 标识为终止报文\n接收窗口大小:能够接收窗口的大小\n检验和:检验首部+数据,检验要加12B伪首部,第四个字段为6\n紧急指针: URG=1才有意义,紧急数据的字节数\n选项: 最大报文长度MSS, 窗口扩大,时间戳 三次握手 SYN, 客户端发送SYN到服务器请求, 目的建立到【客户端-\u0026gt;服务器】的连接 SYN+ACK, 服务器收到客户端的SYN后, 回送SYN和ACK, 其中的SYN表示想要再建立一条【服务器-\u0026gt;客户端】的连接, ACK则表示允许建立【客户端-\u0026gt;服务器】, 也就是说,【客户端-\u0026gt;服务器】连接已通,只剩下【服务器-\u0026gt;客户端】的连接没建立了 ACK,客户端收到服务器的SYN+ACK, 回复ACK,表示允许建立【服务器-\u0026gt;客户端的连接】,此时TCP连接完全建立 四次挥手 FIN, 当数据传完了, 客户端主动发送FIN报文给服务器来关闭【客户端-\u0026gt;服务器】的连接 ACK, 当服务器收到客户端的FIN, 服务器回复ACK, 表示关闭【客户端-\u0026gt;服务器】的连接 FIN, 当服务器确认没有数据传输了, 发送一个FIN，表示要关闭【服务器-\u0026gt;客户端】的连接 ACK, 当客户端收到服务器发的FIN, 回复ACK, 并进入TIME_WAIT(2MSL)状态 ,如果服务器没有反应,说明TCP连接正常断开 UDP UPD 头部信息包括4个内容, 分别是从哪来（源端口）、到哪去（终端口）、有多长（长度）、对不对（校验和）\n应用层协议的支持 TCP: SMTP, FTP, HTTP, TELENT\nUDP: 其他\n网络层 IP 地址的分类 五类IP地址\nA类,开头为0，0.0.0.0 ~ 127.255.255.255, 私有地址为10.0.0.0/8\nB类,开头为10，128.0.0.0 ~ 191.255.255.255,私有地址为172.16.0.0/12\nC类,开头为110，192.0.0.0 ~ 223.255.255.255,私有地址为192.168.0.0/16\nD类,开头为1110，224.0.0.0 ~ 239.255.255.255\nE类,开头为1111，240.0.0.0 ~ 255.255.255.255\n子网掩码 内网中192.168.1.199的前三组是网络号，后一组是主机号，子网掩码就是255.255.255.0\n首先要说明的是：不是某个IP的网络号和主机号决定子网掩码是什么，而是子网掩码决定了某个IP地址的网络号与主机号是什么，IP地址是要搭配子网掩码使用的。例如上面的子网掩码决定了192.168.1.199的前三段192.168.1是网络号，最后一段199是主机号。\n我们再来理解子网掩码的作用，先举个例子，市面上的两个厂家都生产电子秤，每个厂家都坚称他们的秤最准，那你是怎么知道他们的秤到底准不准？很简单，你去找一个 1KG 的国际千克原器，各放到他们的秤上测量，如果秤的测量值是1KG，那这把秤就是准的，子网掩码的作用就相当于这个大家公认的国际千克原器，是我们测量两个IP是否属于同一个网段的一个工具（应该说是让你知道某个IP地址的网络号与主机号分别是什么） 。\n如果让你判断一个IP地址：192.168.1.199的网络号和主机号分别是什么？\n请问你怎么判断？你凭什么说192.168.1是网络号？199是主机号？有什么根据吗？\n但是如果我给你一个IP地址是以下（带子网掩码）形式的：\nIP：192.168.1.199\n子网掩码：255.255.255.0\n那么根据大家公认的规则，你就可以得出这个IP的网络号和主机号了，怎么算呢？\n子网掩码的长度和IP地址一样也是一串32位的二进制数字，只不过为人类的可读性和记忆性的方便，通常使用十进制数字来表示，例如把上面的IP地址和子网掩码都转换成相应的二进制就是下面这样的：十进制 二进制\nIP 地址：192.168.1.199 ‐＞11000000.10101000.00000001.11000111\n子网掩码：255.255.255.0 ‐＞11111111.11111111.11111111.00000000\n十进制的显示形式是给人看的，二进制的显示形式是给计算机看的。。。\n子网掩码的左边是网络位，用二进制数字“1”表示，1的数目等于网络位的长度；右边是主机位，用二进制数字“0”表示，0的数目等于主机位的长度。\n例如上面的子网掩码255.255.255.0的 “1”的个数是左边24位，则对应IP地址左边的位数也是24位;\n十进制 二进制\nIP 地址：192.168.1.199 ‐＞11000000.10101000.00000001.11000111\n子网掩码：255.255.255.0 ‐＞11111111.11111111.11111111.00000000\n则这个IP地址的网络号就是11000000.10101000.00000001 ，转换成十进制就是 192.168.1，网掩码255.255.255.0的 “0”的个数是右边8位，则这个IP地址的主机号就是11000111，转换成十进制就是199.\n作者：知乎用户\n链接：https://www.zhihu.com/question/56895036/answer/154192558\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处.\n"},{"id":13,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/","title":"技术记录","section":"技术","content":" 进制转换 hugo 添加mermaid作图 在 footer.html(页面尾部) 添加以下代码,即可启用mermaid作图\n{{ if (.Params.mermaid) }} \u0026lt;!-- MermaidJS support --\u0026gt; \u0026lt;script async src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // Replace mermaid pre.code to div Array.from(document.getElementsByClassName(\u0026#34;language-mermaid\u0026#34;)).forEach( (el) =\u0026gt; { el.parentElement.outerHTML = `\u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt;${el.innerText}\u0026lt;/div\u0026gt;`; } ); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* Set svg to center */ .mermaid svg { display: block; margin: auto; } \u0026lt;/style\u0026gt; {{ end }} 参考\nhttps://cloud.tencent.com/developer/article/1944123\nhttps://note.qidong.name/2020/07/mermaid/\nCSS 字体 在CSS中，font-size属性可以使用多种单位来指定字体大小。以下是一些常见的font-size单位：\n😋\n像素（px）：像素是绝对单位，它会直接指定字体的像素大小。例如，font-size: 16px; 将文本字体设置为16像素高。\n磅（pt）：磅是印刷单位，通常用于打印。1磅等于1/72英寸，因此它也可以用于屏幕上的字体大小。例如，font-size: 12pt; 将字体设置为12磅。\n毫米（mm）：毫米是长度单位，也可以用于字体大小。例如，font-size: 5mm; 将字体大小设置为5毫米。\n厘米（cm）：厘米也是长度单位，可以用于指定字体大小。例如，font-size: 0.5cm; 将字体大小设置为0.5厘米。\n百分比（%）：百分比是相对于父元素的大小来定义字体大小。例如，font-size: 150%; 表示字体大小是父元素字体大小的150%。\nem：em单位是相对于当前元素的字体大小来定义的。例如，font-size: 1.5em; 表示字体大小是当前元素字体大小的1.5倍。\nrem：rem单位也是相对于根元素（html元素）的字体大小来定义的。这可以使字体大小在整个文档中保持一致。例如，font-size: 1.2rem; 表示字体大小是根元素字体大小的1.2倍。\n刷机参考 TWRP刷机 https://zhuanlan.zhihu.com/p/96968140 Magisk 刷入 https://magiskcn.com/ 沸米计划 https://mi.fiime.cn/FiimePlan/24.html#gallery hugo 日期转时间戳 原因是这样的,我在设置文章更新时间的时候,大部分的日期转时间戳貌似都没问题,除了当天的时间转时间戳,当时时间为当天的 14 点,出来的时间戳一转成时间,结果居然是 22 点, 不断测试,发现不是我代码的问题.\n多次修改无果,问了chatGPT才知道,转时间戳的过程原来还有其他东西会影响\n在处理时间戳时，有一些需要注意的重要事项, ChatGPT 的回答如下\n时间戳精度： 时间戳可以是秒级或毫秒级的，具体取决于系统和编程语言。确保您清楚时间戳的精度，以免出现错误。\n时区和区域性： 时间戳通常是与协调世界时 (UTC) 相关的。时区和区域性的问题可能会导致时间戳的解释不正确。在处理时间戳时，考虑时区和区域性，以便正确地显示和解释日期时间。\n时间戳格式： 时间戳可以采用不同的格式，包括整数（秒或毫秒）、ISO 8601（例如：2023-10-11T14:44:16Z）等。确保您了解所使用的时间戳格式，以正确解释和显示日期时间。\n溢出和范围： 时间戳的范围是有限的，因此要小心处理超出范围的情况。对于以秒为单位的时间戳，通常范围在约1970年至2038年之间。对于以毫秒为单位的时间戳，范围更大，但仍然有限。\n精确性： 根据时间戳的精度，可能会存在一些精度问题。毫秒级时间戳可以提供更高的精度，但仍然有限。在某些情况下，您可能需要考虑四舍五入或截断精度以满足需求。\n跨时区计算： 如果涉及到多个时区，确保正确进行时区转换。使用合适的工具和库来处理跨时区问题。\n日期时间显示： 在显示时间戳时，考虑最终用户的需求和偏好。提供适当的日期时间格式，并考虑将时间戳转换为本地时区以获得更好的用户体验。\n维护和更新： 时间戳可能需要在未来进行维护和更新，以适应不同的需求或问题。时刻注意更新可能会影响应用程序的行为。\n总之，处理时间戳需要小心，要理解时间戳的精度、格式、时区和区域性，以及如何正确地显示和处理日期时间数据。这可以确保您的应用程序或系统在时间方面表现正确。\nhugo 字段bug publishDate字段会有时候让文章显示不出来, 或许是 hugo 内部编译执行的过程出错\nfrontmatter: # publishDate: # - datetimeCreate lastmod: - datetimeUpdate git 代理设置和解决 git config --global https.proxy http://127.0.0.1:1080 git config --global https.proxy https://127.0.0.1:1080 git config --global --unset http.proxy git config --global --unset https.proxy npm config delete proxy 转载 https://gist.github.com/laispace/666dd7b27e9116faece6\n蓝牙音量不正常 经常有小伙伴反馈蓝牙耳机音量小的问题，这里科普一下为什么蓝牙耳机音量小？\n蓝牙耳机音量小，无非两种情况:\n1.手机输出音量小\n2.耳机自生音量调节小了\n好比一根水管，有两个阀门，如果其中一个开关调小，流量就会变小，要想全速流淌，必须要把两个开关全部打开。\n很多小伙伴反馈的是手机音量已经调节到最大还是音量小，其实此时手机的输出已经是最大了，要想调大音量，就必须要调节另一个水龙头，此水龙头自然就是蓝牙耳机自己的音量调节开关了。\n但是，为了把耳机做小，现在很多耳机，特别是TWS耳机，经常没有音量调节按钮，此时想要调节耳机音量，就必须要靠杀器 :蓝牙绝对音量 了。\n那么什么是 蓝牙绝对音量呢？其实，绝对音量就相当于给水管的两个水龙头加了一个联动装置，不管调节哪一个开关，两个水龙头都会同步调节，这样就不存在手机音量调节到最大，耳机或者音箱仍然音量小了。\n但是，需要注意的是，绝对音量功能并不是每个耳机都支持的，有个别耳机，音箱，及车机就是不支持绝对音量的（常见于比较老旧的设备及蓝牙芯片），判断耳机是否支持绝对音量的方法是:\n如果耳机自带音量调节按键，在手机开发者选项中开启绝对音量，然后重新连接蓝牙耳机，重连后从耳机上调节音量，如果手机能显示音量进度条，那么此耳机就是支持绝对音量的。反之则耳机不支持绝对音量。\n当然，如果有的耳机一开始可以调节，可是突然有一天，不能同步调节手机音量了，可能是手机记录了某些不规范操作，把此耳机拉黑了，此时可以尝试从手机端解除配对，重新配对的方式看是否能恢复。\n另外，也有可能是耳机自己记录了手机某些信息，将手机拉黑了，此时可以尝试将耳机恢复出厂设置，通常将耳机恢复出厂设置的方法不会写入说明书，你只能联系销售客服，咨询恢复重置耳机的方法，\n例如大多数TWS耳机重置的方法是:\n1.清除手机配对记录：无蓝牙、无TWS连接状态下，长按触控按键15秒（左右耳分别执行）\n2.断开手机连接：连接手机状态下，无音乐播放、无通话，长按主耳机触控按键5秒\n转载 https://www.realmebbs.com/post-details/1245148418070818816\n"},{"id":14,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E6%B8%85%E5%8D%95/","title":"清单","section":"个人","content":" 软件 【安卓手机】appShare、ES 文件浏览器、Via 浏览器、 b站(带漫游模块)、Clash、手机性能排行、Apple music、微信输入法\n【win】vscode、obsidian、vivaldi（Dark Reader、AdGuard、Stylus、Tampermonkey）、图吧工具箱、autoHotkey（改键位）、 winget\n硬件 宏基传奇Edge：\n机身规格： 356.7242.312.95mm， 1.17kg 屏幕：16英寸，4k，OLED，E4，屏占比92%，支持HDR500，德国莱茵TUV硬件级低蓝光认证和eyesafe显示认证 性能：R7-6800U，16GB LPDDR5 6400MHz双通道内存，512GB PCIe 4.0 SSD，54Wh 续航8小时 外设接口：单色背光，电源指纹二合一，前置FHD摄像头（支持TNR时域降噪和AI降噪），Wifi 6e 和蓝牙5.2，2个全功能Type-C接口中、1个HDMI接口、2个USB3.2接口、1个耳麦接口 其他：标配65W Type-C 适配器， 附录 【autoHotkey-changeKeys.ahk】：\n; Esc 映射成 AltTab *Esc::send \u0026#34;{Blind}!{Tab}\u0026#34; ; 左Alt -\u0026gt;Ctrl *LAlt::Ctrl ;大写键-\u0026gt;回车键 *CapsLock::Enter ;Tab键 -\u0026gt;删除键 *Tab::Backspace ; `键 -\u0026gt; Tab键 *`::Tab ;win+鼠标滚轮上(下滚)滚增加(减少)音量 ;win+点击鼠标滚轮暂停或者播放 A_HotkeyInterval := 0 #WheelUp::Volume_Up #WheelDown::Volume_Down #MButton::Media_Play_Pause ;禁用按win键开始菜单弹出,快捷键不受影响 ~LWin::Send \u0026#34;{Blind}{vkE8}\u0026#34; "},{"id":15,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/","title":"设计语言","section":"技术","content":" 颜色 颜色要醒目, 令人舒适\n不同颜色, 代表不同意义\n重的亮深, 轻的暗浅\n大小 字多字小, 字段字大\n重的大, 轻的小\n留白 标志 下划线: 超链接\n"},{"id":16,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","title":"数据结构和算法","section":"理论知识","content":" 参考 https://www.cs.usfca.edu/~galles/visualization/Algorithms\nhttps://algo.itcharge.cn\nhttps://www.hello-algo.com\nhttps://pdai.tech/md/algorithm/alg-basic-overview.html\nhttps://www.runoob.com/w3cnote/ten-sorting-algorithm.html\nhttps://www.runoob.com/w3cnote/selection-sort.html\n排序算法 冒泡排序\n两两比较, 符合规则就换, 接着滑动窗口往后移动\n选择排序\n每次选最大的(无序区)放到最后(有序区)\n插入排序\n每次选的元素插入到有序区,类似打牌时的排序\n在第五步排序的过程。程序运行到当前位置，已排好的子表中包含了 “17，26，54，77，93”五个数据。我们想让31插入该子表中。第一次，31和93比较，93要移到 31右边。同理，77和54也要移位。遇到26时，移动步骤停止，31被插入到此处。此时我们就有了 一个含6个数据项的已排好的子表\n快速排序\n归并排序\n堆排序\n桶排序\n计数排序\n基数排序\n树 完美二叉树(满二叉树) 所有节点都是满的\n完满二叉树 只有叶子节点未满，且叶子节点尽量靠左填充。\n平衡二叉树 任何两个子树高度差小于2\n"},{"id":17,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/","title":"数学知识","section":"理论知识","content":" 等比数列公式 进制转换 十进制转二进制 十进制数转换为二进制数时，由于整数和小数的转换方法不同，所以先将十进制数的整数部分和小数部分分别转换后，再加以合并。\n十进制整数转换为二进制整数采用\u0026quot;除2取余，逆序排列\u0026quot;法。具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为0时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。\n二进制转十进制 要从右到左用二进制的每个数去乘以2的相应次方，或者把二进制数首先写成加权系数展开式，然后按十进制加法规则求和。这种做法称为\u0026quot;按权相加\u0026quot;法。\n二进制数1000110转成十进制数可以看作这样：\n数字中共有三个1 即第一位一个，第二位一个，第六位一个，然后对应十进制数即2的1次方+2的2次方+2的6次方， 即1000110=64+0+0+0+4+2+0=70\n"},{"id":18,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/","title":"网站收藏","section":"技术","content":" 学习网站 全历史 https://www.allhistory.com 今日热榜 https://rebang.today 计网 http://home.ustc.edu.cn/~chaf/course/network.html https://www.runoob.com/w3cnote/summary-of-network.html 软件工具 画图工具 https://handraw.top Chatgpt https://chat.openai.com 科学上网 追云加速 https://www.zhuiyun.shop 一元机场 https://yfh4rrze3snwnnwj.xn--4gq62f52gdss.vip/ 机场推荐 http://www.maomeng.cf kaggle https://www.kaggle.com SMS-activate https://sms-activate.org 内网穿透 https://www.natfrp.com/ autoHotKey https://wyagd001.github.io/v2/docs/ 建站参考 hugo https://hugo.aiaide.com/post\n另一个hugo文档 https://gohugobrasil.netlify.app\nLyricify https://github.com/WXRIW/Lyricify-App\n颜色墙 http://zhongguose.com/#shangengzi\n博客部署\nnameSilo https://www.namesilo.com 阿里云 https://cn.aliyun.com Vercel https://vercel.com jsDelivr * vercel https://cloud.tencent.com/developer/article/1875306 元素生成\ndigraph https://zhuanlan.zhihu.com/p/21993254 fullcalendar https://fullcalendar.io/docs Lunar https://6tail.cn/calendar/api.html graphviz https://graphviz.org plantuml https://plantuml.com/zh/ 参考博客\n干志雄 https://ganzhixiong.com 雷雷屋头 https://ll.sc.cn "},{"id":19,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91/","title":"维基百科","section":"技术","content":"维基百科（Wikipedia）提供了一套API，允许开发者通过HTTP请求来获取和检索维基百科的内容。以下是一些关于维基百科API的基本信息：\n维基百科 API 基本信息 Endpoint（终端点）： https://en.wikipedia.org/w/api.php （英语维基百科的API终端点，你可以替换 en 为其他语言标识符）\n请求方式： 主要使用HTTP GET请求，但也支持POST请求。\n返回格式： 默认返回JSON格式，也可以选择其他格式，如XML。\n常用维基百科 API 请求参数 action（动作）： 定义API的行为，常见值包括 query（查询）、parse（解析）、opensearch（开放搜索）等。\nformat（格式）： 指定返回结果的格式，常见值包括 json 和 xml。\ntitles（标题）： 指定要查询的页面标题，可以是单个标题或多个标题。\npageid（页面ID）： 指定要查询的页面的ID，与标题二选一使用。\nprop（属性）： 查询页面的属性，如 revisions（修订版本）、categories（分类）等。\nrvprop（修订版本属性）： 用于指定 revisions 属性的具体内容，如 content（内容）、timestamp（时间戳）等。\nredirects（重定向）： 控制是否将重定向页面包含在结果中。\nlimit（限制）： 用于限制查询结果的数量。\n示例：获取页面内容 https://en.wikipedia.org/w/api.php?action=query\u0026amp;format=json\u0026amp;titles=Python_(programming_language)\u0026amp;prop=revisions\u0026amp;rvprop=content 这个例子用于获取“Python编程语言”页面的内容。你可以通过修改参数来执行不同的操作和查询其他页面。\n请注意：使用维基百科API时，你可能需要遵循维基百科的使用政策和服务条款。详细的API文档和更多信息可以在 维基百科开发者页面找到。\n"},{"id":20,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E4%BA%94%E7%AC%94%E8%BE%93%E5%85%A5%E6%B3%95/","title":"五笔输入法","section":"理论知识","content":" 笔画\n笔画是指汉字书写时不间断的一次连续写成的一个线条 字根\n笔画交叉复合而成的固定结构,是构成汉字的最基本单位 不符规律的键位 横 G[五] F[二] D[古] S[木丁西] A[工] 竖 "},{"id":21,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E5%85%B4%E8%B5%B7/","title":"兴起","section":"个人","content":" 首页美化计划 目的是增强博客的丰富度和内容,使得博客不再那么枯燥无味,并进一步将个人数据透明化和可视化\n步骤如下\n初步利用网页组件美化 搞定数据的存储和传输 图表可视化 万物皆有定数 方式: 系统api/相关软件/自行记录\n数据格式: JSON\n内容: 与我有关的所有数据,单位为天\n步数 睡眠时长, 睡眠起始点 键盘输入字符数量 \\ 鼠标点击次数 饮水量 \\ 吃饭内容 洗澡 \\ 洗头 购物记录 重要的定数 计算力 记忆力 意志力 一言 介绍 在息屏或者锁屏状态下显示一段话,可以运行在移动端或者PC端,每隔一定的时间按照某种顺序来切换另一段话,数据接口可以为本地或网络上的.JSON文件和.CSV文件等.\n待定计划 短信应用开发 移动端和PC端应用开发 参考内容 http://blog.lwons.com/archieve/3_entity_search_databases.html https://languageresources.github.io/2018/03/07/%E8%8B%97%E8%8F%81%E8%8F%81_Wikidata%E7%9F%A5%E8%AF%86%E5%BA%93/ https://www.wikidata.org/w/api.php?action=wbsearchentities\u0026search=Fudan\u0026language=en\u0026limit=20\u0026format=json Wikipedia json数据 https://dumps.wikimedia.org/wikidatawiki/entities/ 有书可读方案 电子书 下载到本地 优秀的阅读体验 个人存储方案 NAS\n好处在于可扩展存储，数据安全，价格也不算特别高\n坏处在于速度和可用性需要网络支持，需要内网穿透或者公网IP，且需要24小时开启，费电\nType-C U盘\n好处在于速度有保障、不需要依赖网络\n坏处在于用时候没法充电，容易丢失，带来发热量，价格略贵\nSD 卡 存储\n好处在于速度有保障、不需要依赖网络\n坏处在于容易丢失，带来发热量，价格贵\n网络云盘（阿里云盘等）\n好处在于可扩展存储，数据安全，价格也不算特别高\n坏处在于速度和可用性需要运营商支持，一般来说，速度都比较慢\n最后总结一下,四个存储方案,供大家参考\n价格 读写速度 可扩展性 稳定性 其他问题 NAS 硬盘便宜,NAS本身贵,网费和电费月支 网速 多块硬盘 极其稳定 Type-C U盘 价格 SD 卡存储 网络云盘(阿里云盘等) "},{"id":22,"href":"/posts/%E4%B8%AA%E4%BA%BA/%E4%BF%AE%E8%BA%AB/","title":"修身","section":"个人","content":" 定时 定时体检,选重要的关键的体检项目, 原则 极简, 如无必要勿增实体 实用, 凡事要看它有没有用 长远, 不要只关注今天和昨天 果断, 当断不断,必受其乱 耐心, 不要傲慢和偏见 稳步, 区分轻重缓急 隔离，工作，娱乐，休息三者的时间空间不能相同 必做 11 点前睡觉\n不在手机上刷短视频\n多看书\n408科目复习\n刷算法题\n做 50道计算题\n骑车回去\n20 个俯卧撑\n100 个单腿,左50,右50\n穿好衣服,整理仪容仪表\n打球\n交流 求同存异, 不说服, 列事实 "},{"id":23,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E5%BA%94%E7%94%A8%E5%B1%82-qa/","title":"应用层-Q\u0026A","section":"理论知识","content":"应用层是指电脑上各种应用软件进程通过何种应用层协议来使用网络提供的通信服务\n域名系统DNS是什么 域名系统是指 Internet 中用于把主机名字转换成IP的系统\n为啥 IP 数据包不使用域名而是用 IP 地址呢 因为 IP 地址的长度是固定的32位或者固定的128位，而域名的长度是可变的\n域名服务器DNS使用频率非常高，如何解决域名服务器可能出现的故障问题呢 域名服务器DNS被设计成联机分布式数据系统，采用B/S架构, 大多域名在本地进行解析,少量解析需要通过互联网.\n域名到IP地址的解析过程是怎么样的呢 当应用需要将域名转 IP 地址时, 应用就调用解析程序( resolver ), 把待解析的域名放在 DNS 请求报文中, 以 UDP 方式发送给本地域名服务器,本地服务查找域名之后, 把对应的 IP 地址发送给应用主机.\n域名是怎么组成的呢 早期是无层次的名字空间, 后来因为用户数量急剧增加, 管理这个域名集合空间非常困难, 互联网才用了层次树状结构的命名方法, 任何在互联网上的主机或者路由器, 都有一个唯一层次结构的名字(即域名)，域名由标号和点组成，如 www.baidu.com ，其中com为顶层域名，baidu为二级域名，www为三级域名。\n互联网域名空间是一个倒过来的树状结构，最上面的是根，根下面的第一层是顶级域名，第二层是二级域名，第三层是三级域名，以此类推，最后一层是叶子节点，也就是这主机名字。\n域名中的标号是怎么规定的呢 由英文字母和数字组成，不区分大小写，每个标号不超过63个字符（为记忆最好不要超过12个字符）。\n前面提到域名服务器是联机分布式数据系统，那么它是如何分布管理的呢 域名服务器采用分区的方法来管理，因为这样相比起按照域名来划分，会使域名服务器的数量太多，使域名系统的运行效率降低。\n区（zone）是指域名服务器负责的范围。\n域名服务器之间的解析过程是怎么样的呢？ 主机向本地域名服务器查询基本采用递归查询。\n本地域名服务器想根域名服务器采用迭代查询。\n文件传输协议有哪些？ 文件传输协议包括两种FTP和TFTP协议，FTP基于TCP支持文件传输和交互，而TFTP基于UDP支持文件传输不能交互。\nTELNET 是什么协议？ TELNET 是一个基于TCP的简单远程终端协议，用于远程登录另一台主机。\nWWW 、HTTP、HTML 是指什么？两者有什么关系 ？ WWW（World Wide Web）是一个基于HTTP协议的、分布式的、超文本的信息存储系统。\nHTTP （HyperText Transfer Protocol）是一个无状态的、基于TCP的应用层协议。\nURL 的格式？URL 是否区分大小写? \u0026lt;协议\u0026gt;://\u0026lt;主机\u0026gt;:\u0026lt;端口\u0026gt;/\u0026lt;路径\u0026gt;\n不区分大小写\nHTTP 的传输过程 建立 TCP 连接 B发送 请求报文 C发送 响应报文 关闭 TCP 连接 HTTP 的状态码分别代表什么? 1xx代表通知信息,如何请求收到了或正在处理\n2xx代表成功,如接受或知道了\n3xx代表重定向, 如完成请求还要进一步采取行动\n4xx代表客户端请求错误,如因为客户端输入错误的URL而无法访问\n5xx代表服务器响应错误, 如服务器已关闭连接.\n为什么存在 Cookie 这种东西? 由于 HTTP 本身是无状态的，但是在一些网站实际业务中不可避免要记住用户的当前状态，如果要记住用户的登录状态，当用户登录成功之后，网站服务器便在响应中设置一个识别码“Set-cookie”，当用户的浏览器收到响应之后，就会将其中的 Cookie 予以保存到本地，并在下次请求时将 Cookie 放到请求头中去。\n"},{"id":24,"href":"/posts/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E8%BF%90%E8%BE%93%E5%B1%82-qa/","title":"运输层-Q\u0026A","section":"理论知识","content":" 运输层是干啥的？为啥会有运输层 运输层是为进程与进程之间通信服务用的，规定了进程与进程之间应该以何种协议进行传输数据。\n如果没有运输层，通信数据的传输将不可靠稳定，从而影响整个网络的通信速度质量。\n运输层包括哪些协议内容？这些协议内容有哪些异同点？ 运输层主要包括TCP【传输控制协议】协议和UDP【用户数据报协议】协议。\n不同点：\nUDP 不需要建立连接直接发送数据包，TCP需要进行三次握手再发送数据 UDP支持一对一、一对多、多对一、多对多的相互通信，TCP支持一对一的点对点通信 UDP不保证数据传输能顺利抵达目的，TCP通过一些内部协议来保证数据传输的一定抵达目的 TCP 协议的三次握手四次挥手过程是怎么样的？ 三次握手是指客户端和服务端之间建立连接的过程，而四次挥手则是两者释放连接的过程。\n第一次握手：客户向服务端主动发送信号【SYN】，具体内容为我已经准备好同步了，如果你要开始与同步，发送一个确认码ack给我（Acknowledge number，值我发送的随机码+1），代表你真的收到我发的东西了。\n"},{"id":25,"href":"/posts/%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"正则表达式","section":"技术","content":"正则表达式的所有元字符\n正则表达式的所有元字符包括(markdown表格列出来)：\n元字符 描述 . 匹配任意字符（除了换行符） \\d 匹配数字字符 \\D 匹配非数字字符 \\w 匹配单词字符（字母、数字、下划线） \\W 匹配非单词字符 \\s 匹配空白字符（空格、制表符、换行符等） \\S 匹配非空白字符 ^ 匹配字符串的开头 $ 匹配字符串的结尾 * 匹配前面的元素零次或多次 + 匹配前面的元素一次或多次 ? 表示前面的元素是可选的，匹配零次或一次 {n} 表示前面的元素恰好出现 n 次 {n,} 表示前面的元素至少出现 n 次 {n,m} 表示前面的元素出现 n 到 m 次之间 [] 字符集，匹配括号中任意一个字符 [^] 或 [^\u0026hellip;] 否定字符集，匹配除了括号中指定的任意字符之外的其他字符 "},{"id":26,"href":"/moments/%E4%B8%AD%E5%9B%BD/","title":"中国","section":"Moments","content":" 改革开放由中国共产党第二代中央领导集体核心邓小平提出和创立，是在1978年12月18日中共十一届三中全会后，开始实施的一系列以经济为主的改革措施，可总结为“对内改革，对外开放” https://photocdn.sohu.com/20081008/Img259904537.jpg 1979-04-01 @@@ “中华人民共和国! 中央人民政府! 今天成立了！” https://www.gov.cn/test/images/images/00188b27c9090bf5a75813.jpg 1949-10-01 "}]